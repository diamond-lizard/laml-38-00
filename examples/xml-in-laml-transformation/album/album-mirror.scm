; This file is generated by an LAML script based on the LAML tool tools/xml-in-laml/xml-in-laml.scm. DO NOT EDIT!

; lib/xml-in-laml/xml-in-laml.scm is not loaded here. 
; You must load it your self prior to the loading of this file.

(define album-xml-transliterate-character-data? #t)
(define album-xml-char-transformation-table html-char-transformation-table)
(define album-xml-non-transliteration-elements '())
(define album-xml-preformatted-text-elements '())
(define album-xml-pass-default-dtd-attributes? #f)
(define album-xml-accept-only-string-valued-attributes? #t)
(define album-xml-document-type-declaration "")
(define album-xml-represent-white-space? #f)


; Empty temporary language map
(set! temp-language-map (quote ()))



;;; The validation procedures

(define (album-album-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0) (dfa (quote (finite-state-automaton 0 (10) #((0 b 1) (1 c 2) (2 d 3) (2 e 4) (3 e 4) (4 f 5) (5 f 6) (5 g 7) (6 f 6) (6 g 7) (7 h 8) (8 i 9) (9 j 10)) #((artist  . c) (catalogno  . f) (coverart  . e) (notes  . i) (personnel  . g) (recordingdate  . d) (terminator$$  . j) (title  . b) (tracks  . h)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "album"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "album")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "album"))))

(define (title-album-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0)) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "title"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "title")) (if xml-validate-contents? (validate-as-pcdata! contents "title"))))

(define (artist-album-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0)) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "artist"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "artist")) (if xml-validate-contents? (validate-as-pcdata! contents "artist"))))

(define (recordingdate-album-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("date" "CDATA" "#IMPLIED") ("place" "CDATA" "#IMPLIED")))) (req-n 0)) (xml-check-for-empty-contents! contents "recordingdate") (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "recordingdate"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "recordingdate"))))

(define (coverart-album-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("style" "CDATA" "#REQUIRED")))) (req-n 1) (dfa (quote (finite-state-automaton 0 (2) #((0 b 1) (0 c 2) (1 c 2)) #((location  . b) (terminator$$  . c)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "coverart"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "coverart")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "coverart"))))

(define (location-album-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("thumbnail" "CDATA" "#IMPLIED") ("fullsize" "CDATA" "#IMPLIED")))) (req-n 0)) (xml-check-for-empty-contents! contents "location") (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "location"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "location"))))

(define (catalogno-album-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("label" "CDATA" "#REQUIRED") ("number" "CDATA" "#REQUIRED") ("format" ("CD" "LP" "MiniDisc") "#IMPLIED") ("releasedate" "CDATA" "#IMPLIED") ("country" "CDATA" "#IMPLIED")))) (req-n 2)) (xml-check-for-empty-contents! contents "catalogno") (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "catalogno"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "catalogno"))))

(define (personnel-album-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0) (dfa (quote (finite-state-automaton 0 (3) #((0 b 1) (1 b 2) (1 c 3) (2 b 2) (2 c 3)) #((player  . b) (terminator$$  . c)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "personnel"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "personnel")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "personnel"))))

(define (player-album-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("name" "CDATA" "#REQUIRED") ("instrument" "CDATA" "#REQUIRED")))) (req-n 2)) (xml-check-for-empty-contents! contents "player") (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "player"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "player"))))

(define (tracks-album-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0) (dfa (quote (finite-state-automaton 0 (2) #((0 b 1) (0 c 2) (1 b 1) (1 c 2)) #((terminator$$  . c) (track  . b)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "tracks"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "tracks")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "tracks"))))

(define (track-album-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("title" "CDATA" "#REQUIRED") ("credit" "CDATA" "#IMPLIED") ("timing" "CDATA" "#IMPLIED")))) (req-n 1)) (xml-check-for-empty-contents! contents "track") (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "track"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "track"))))

(define (notes-album-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("author" "CDATA" "#IMPLIED")))) (req-n 0)) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "notes"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "notes")) (if xml-validate-contents? (validate-mixed-contents-by-simple-means! contents (quote (albumref trackref)) "notes"))))

(define (albumref-album-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("link" "CDATA" "#REQUIRED")))) (req-n 1)) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "albumref"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "albumref")) (if xml-validate-contents? (validate-as-pcdata! contents "albumref"))))

(define (trackref-album-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("link" "CDATA" "#IMPLIED")))) (req-n 0)) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "trackref"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "trackref")) (if xml-validate-contents? (validate-as-pcdata! contents "trackref"))))

;;; Make and put XML mirror functions in the temporary language map:
(set! temp-mirror-function (generate-xml-mirror-function album-album-laml-validate! "album" (quote ()) (quote double) (quote album) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "album" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function album-album-laml-validate! "album" (quote ()) (quote double) (quote album) #t #f))
(define album temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function title-album-laml-validate! "title" (quote ()) (quote double) (quote album) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "title" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function title-album-laml-validate! "title" (quote ()) (quote double) (quote album) #t #f))
(define title temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function artist-album-laml-validate! "artist" (quote ()) (quote double) (quote album) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "artist" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function artist-album-laml-validate! "artist" (quote ()) (quote double) (quote album) #t #f))
(define artist temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function recordingdate-album-laml-validate! "recordingdate" (quote ()) (quote single) (quote album) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "recordingdate" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function recordingdate-album-laml-validate! "recordingdate" (quote ()) (quote single) (quote album) #t #f))
(define recordingdate temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function coverart-album-laml-validate! "coverart" (quote ()) (quote double) (quote album) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "coverart" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function coverart-album-laml-validate! "coverart" (quote ()) (quote double) (quote album) #t #f))
(define coverart temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function location-album-laml-validate! "location" (quote ()) (quote single) (quote album) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "location" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function location-album-laml-validate! "location" (quote ()) (quote single) (quote album) #t #f))
(define location temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function catalogno-album-laml-validate! "catalogno" (quote ()) (quote single) (quote album) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "catalogno" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function catalogno-album-laml-validate! "catalogno" (quote ()) (quote single) (quote album) #t #f))
(define catalogno temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function personnel-album-laml-validate! "personnel" (quote ()) (quote double) (quote album) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "personnel" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function personnel-album-laml-validate! "personnel" (quote ()) (quote double) (quote album) #t #f))
(define personnel temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function player-album-laml-validate! "player" (quote ()) (quote single) (quote album) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "player" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function player-album-laml-validate! "player" (quote ()) (quote single) (quote album) #t #f))
(define player temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function tracks-album-laml-validate! "tracks" (quote ()) (quote double) (quote album) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "tracks" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function tracks-album-laml-validate! "tracks" (quote ()) (quote double) (quote album) #t #f))
(define tracks temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function track-album-laml-validate! "track" (quote ()) (quote single) (quote album) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "track" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function track-album-laml-validate! "track" (quote ()) (quote single) (quote album) #t #f))
(define track temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function notes-album-laml-validate! "notes" (quote ()) (quote double) (quote album) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "notes" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function notes-album-laml-validate! "notes" (quote ()) (quote double) (quote album) #t #f))
(define notes temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function albumref-album-laml-validate! "albumref" (quote ()) (quote double) (quote album) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "albumref" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function albumref-album-laml-validate! "albumref" (quote ()) (quote double) (quote album) #t #f))
(define albumref temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function trackref-album-laml-validate! "trackref" (quote ()) (quote double) (quote album) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "trackref" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function trackref-album-laml-validate! "trackref" (quote ()) (quote double) (quote album) #t #f))
(define trackref temp-mirror-function)

; Register the name of the language:
(register-xml-in-laml-language (quote album) temp-language-map)

; Define the language variable
(define album (activator-via-language-map (quote album)))


; This file can ONLY be used together with the LAML file
; styles/xml-in-laml/lecture-notes-themes/lecture-notes-themes.scm.
; It means that the only way to process a LENO theme file is through
; the XML-in-LAML interface.

; The theme part of LENO. Themes are normally connected 
; to sections of note pages. Extra text and material can be
; added to a theme, however. The single sourcing approach
; used in LENO is not used with respect to themes. Themes have
; their own source files. The theme files rely on the -.lsp
; files generated by LENO when it processes the normal note pages.

; -----------------------------------------------------------------------------
; LOADING OF LIBARIES:

; general.scm is loaded by laml.scm
(lib-load "cgi.scm")
(lib-load "encode-decode.scm")


; HTML mirrors loaded in the xml-in-laml part:
                                        ; styles/xml-in-laml/lecture-notes-themes/lecture-notes-themes.scm

(lib-load "color.scm")
(lib-load "time.scm")
(lib-load "file-read.scm")

; ---------------------------------------------------------------------------------------------------
; Theme constants

; An ad hoc variable that helps make better result when producing black and white output.
; Introduced to make better emphasis in source programs.
; Normally always #f
(define black-and-white-edition #f)

(define top-level-theme-file-name "theme-index")

; lecture-id corresponds to the name of the theme source file - will be defined in lecture-note-kernel.scm
; You can use theme-id as an alias in this file.
; The function original-lecture-id is helpful to get the lecture id of the primary LENO source.

(define language-preference 'english)

(define theme-font-size 3)
(define theme-background-color white)
(define items-box-color (make-color 245 245 245))
(define program-frame-color (make-color 225 225 255))
(define line-number-bg-color (make-color 230 230 230))
(define table-cell-color (make-color 255 255 193))  ; (make-color 228 160 143)
(define line-number-fg-color (rgb-color-encoding 150 150 150))
; The maximum number of sections for one column index
(define one-column-limit-top-level-index 18) 

; Top level index: The width of each column in case of two column layout is used.
(define two-column-top-level-index-width 400)

; Theme global variables
(define aux-list '())
(define aux1-list '())         ; Covering a single theme (chapter).
(define total-aux1-list '())   ; covering entire material - all themes in all files.
(define theme-sub-number 0)
(define program-sub-number 0)
(define figure-sub-number 0)
(define table-sub-number 0)
(define syntax-sub-number 0)
(define concepts-sub-number 0)
(define side-box-sub-number 0)
(define program-text-font-size "80%")  ; assigned via front-matters attribute

(define theme-cross-reference-list '())
(define current-theme-page-name #f)  ; the file name of the current page, as they are produced

(define ref-caption-map '())  ; the reference caption map collected in the current run
(define old-total-ref-caption-map #f) ; the reference caption map, from the entire material, collected from the previous run

(define lsp-contents-in-this-lecture '())  ; in this list we collect the full contents of the themes as Lisp data structure 

(define default-default-annotation-kind 'ignore)  ; before December 16, 2007:  unfold-after

; A list of ref-entries that help us generate ref clauses - purely for author convenience 
(define ref-info-list '())

(define spacy-references? #f)  ; do we add white space around (ref ...) clauses

(define make-slide-view? #t)              ; assigned from attributes
(define make-annotated-slide-view? #f)
(define make-aggregated-view? #f)

(define do-exercise-linking-in-themes? #f)  ; assigned from attributes
(define do-program-linking-in-themes? #f)  

(define default-annotation-map
 '((source-program . caption)
   (tabular . caption)
   (image . caption)
   (language-syntax . caption)
  ))

(define (default-annotation-handling element-type)
 (let ((result (defaulted-get (as-symbol element-type) default-annotation-map #f)))
   (as-symbol (if result result default-default-annotation-kind))))

; A number between 0 and 2, telling how verbose the processing of a theme will be.
; 0 means silence.
(define theme-verbosity 2)

(define preferred-theme-page-width 800)
(define theme-box-indent 10)
(define caption-width 400)

; author mode helps the author of the theme material. #f is the normal value, however.
(define themes-author-mode #f)

; Either web og paper (a symbol). Use the value paper when we produces theme hard copies.
; The normal - and the default value - is web
(define themes-presentation-medium 'web)

; Do we make a lecture wide aggregation of the themes?
(define (lecture-aggregation? medium)
  (eq? medium 'paper))

(define aggregated-theme-port #f)

(define make-cross-reference-section? #t)

(define course-home-url #f)
(define author-home-url #f)
(define note-download-url #f)


; ---------------------------------------------------------------------------------------------------
; The directory in which the LENO Scheme software resides:
(define leno-software-directory (string-append laml-dir "styles/lecture-notes/"))

(define (leno-software-dir-file . x) (string-append leno-software-directory (list-to-string x "")))

; -----------------------------------------------------------------------------------------------------------
; TOP LEVEL THEME FORMS:

(define theme-page-number 0) ; initialized in begin-themes below

(define (do-begin-themes)
 (let ((aggregated-theme-file (destination-path (aggregated-themes-name (original-lecture-id theme-id)))))

  ; First re-assign lecture-sections to the original form: A list of entries of the form ("lecture-id" "lecture-title").
  (if (simple-list-lecture-sections-format? lecture-sections)
     (set! lecture-sections
       (map (lambda (lid) (list lid (find-original-chapter-title lid))) lecture-sections)))

  (set! theme-page-number (start-section-of-lecture theme-id lecture-list))
  (set! page-number 0)  ; defined in lecture-notes-kernel.scm
  (set! remembered-global-themes-page-list '()) ; resetting cach of global-themes-page-list

  (set! all-bibtex-entries 
        (flatten (map file-read bibtex-files)))

  (set! ref-caption-map '())

  (set! old-total-ref-caption-map (all-ref-entries))

  (if (not (and (list? lecture-author-info) (not (null? lecture-author-info))))
      (set!  lecture-author-info author-and-affiliation-list))

  

  (if (lecture-aggregation? themes-presentation-medium)
      (begin
        (if (file-exists? aggregated-theme-file) (delete-file aggregated-theme-file))
        (set! aggregated-theme-port (open-output-file aggregated-theme-file))

        (write-string-to-port 
         (string-append
          (start-tag "html")
          (head (title "Paper edition") (style 'type "text/css" "A {text-decoration: \"none\";}") 
                (link 'href "stylesheets/stylesheet.css" 'rel "stylesheet" 'title "stylesheet" 'type "text/css") ; hack Feb 22, 2008
          )
          (let ((body-attributes (list 
                                  'bgcolor (rgb-color-encoding theme-background-color)
                                  'text (rgb-color-encoding black)
                                  'link (rgb-color-encoding black)
                                  'vlink (rgb-color-encoding black))))
            (apply start-tag (cons "body" body-attributes))))
         aggregated-theme-port)))

  (set! total-aux1-list 
    (flatten (map read-aux1-file-if-exists (map (compose theme-name-of first) lecture-sections))))

 )
)

; aux-file-name in lecture-notes-kernel.scm


(define (do-end-themes)

 (if (file-exists? (aux-file-name lecture-id))
     (delete-file (aux-file-name lecture-id)))

 (if (file-exists? (aux1-file-name lecture-id))
     (delete-file (aux1-file-name lecture-id)))
 
 ; generate new theme aux file. Chapter level
 (with-output-to-file (aux-file-name lecture-id)
     (lambda () (write (cons notes-title (reverse aux-list)) )))

 ; generate new theme aux1 file. Section level
 (with-output-to-file (aux1-file-name lecture-id)
     (lambda () (write (cons notes-title (reverse aux1-list)) )))

 (make-top-level-theme-index lecture-list)

 ; generate new ref file (mapping (theme-page-name lecture-id page-id element-type element-id-or-number) to numbers)
 (if (file-exists? (ref-file-name))
     (delete-file (ref-file-name)))

 (with-output-to-file (ref-file-name)
     (lambda () (write (reverse ref-caption-map))))


 ; make full contents lsp file in order to save the entire contents for querying purposes.
 (if (file-exists? (lsp-file-name theme-id))
     (delete-file (lsp-file-name)))

 (with-output-to-file (lsp-file-name theme-id)
     (lambda () (write (reverse lsp-contents-in-this-lecture))))


 (if themes-author-mode
     (write-text-file
      (author-ref-help (reverse ref-info-list))
      (destination-path (author-ref-help-name theme-id))))


 ; theme front matters page
 (write-text-file 
     (theme-front-matters)
     (destination-path (theme-front-matters-name)))

 (if (lecture-aggregation? themes-presentation-medium)
  (begin
    (write-string-to-port 
      (string-append (end-tag "body")(end-tag "html"))
      aggregated-theme-port)
    (close-output-port aggregated-theme-port)))


 (display-message "END LENO THEME PROCESSING")

 
  
)

; The list of page-ids for which there is a subsection in the currently processed theme
(define section-page-ids-in-theme '())   ; assigned by do-theme

; The list of titles of each title in a theme. A parallel list to section-page-ids-in-theme.
(define section-titles-in-theme '())     ; assigned by do-theme

; The page id of the current chapter. This corresponds to the id of the leno note-page with section-title element.
(define chapter-page-id #f)              ; assigned by do-theme


(define (do-theme . x)
 (set! theme-page-number (+ theme-page-number 1))  ; theme global numbering
 (set! page-number (+ page-number 1))  ; per lecture numbering
 (set! theme-sub-number 0)

 (set! program-sub-number 0)
 (set! figure-sub-number 0)
 (set! table-sub-number 0)
 (set! syntax-sub-number 0)
 (set! concepts-sub-number 0)
 (set! side-box-sub-number 0)
 (set! pending-exercise-hr? #f)

 ; Reset theme-cross-reference-list to zero after do-theme is done to provide for bib-cites within theme-text.
 ; (set! theme-cross-reference-list '()) ; the list of cross references in this theme

 (let* ((theme-element (make-element 'theme x))
        (theme-id (as-symbol (get 'id (new-element-attributes theme-element))))
        (theme-elements (new-element-contents theme-element))
        (theme-attributes (new-element-attributes theme-element))

        (theme-title-element (dig-out-title theme-elements))  ; extract from theme-elements?

        (aux-entry (make-aux-entry theme-title-element theme-id #t page-number))   ; chapter level  (theme level).
;!;        (aux1-entry (make-aux1-entry 'section-title theme-title-element (as-string theme-id) (find-chapter-page-id-in theme-elements) #f theme-page-number #f))
        )


    (set! section-page-ids-in-theme (find-sections-in-theme theme-elements))
    (set! section-titles-in-theme (find-titles-in-theme theme-elements))  
    (set! chapter-page-id (find-chapter-page-id-in theme-elements))

    (set! current-theme-page-name (theme-name lecture-id theme-id))

    (if (> theme-verbosity 0) (display-message (string-append (as-string lecture-id) ":" (as-string theme-id))))

    (set! aux-list (cons aux-entry aux-list))
;!;    (set! aux1-list (cons aux1-entry aux1-list))

    (let ((lsp-page (make-lsp-page theme-id theme-elements))
         )
      (set! lsp-contents-in-this-lecture (cons lsp-page lsp-contents-in-this-lecture)))

    (let ((theme-contribution
            (as-theme-text
             (con
              (apply con
                     (map
                      (lambda (e)
                        (present-theme-element
                         (new-element-tag e)
                         (new-element-contents e)
                         (new-element-attributes e)
                         ) 
                        ) 
                      theme-elements)
                     )
              (if make-cross-reference-section?
                  (theme-reference-part (reverse theme-cross-reference-list))
                  "")
              ))))

    (write-text-file
     (standard-theme theme-title-element theme-contribution)
     (destination-path (theme-name lecture-id theme-id)))

    (if (lecture-aggregation? themes-presentation-medium)
        (write-string-to-port theme-contribution aggregated-theme-port))

  ))

  (set! theme-cross-reference-list '()) ; the list of cross references in this theme
)

(define (dig-out-title theme-elements)
 (let* ((relevant-theme-element 
          (find-in-list (lambda (e) (equal? "section-title" (get 'element-type (new-element-attributes e)))) theme-elements)))
  (if relevant-theme-element
      (let* ((attr-list (new-element-attributes relevant-theme-element))
             (section-title-element (lookup-element (get 'lecture-id attr-list) (get 'page-id attr-list) 'section-title '*)))
         (if section-title-element
             (car (element-contents section-title-element))
             "???"))
      "???")))

(define (find-sections-in-theme theme-elements)
  (map (lambda (te)
          (let ((attr-list (new-element-attributes te)))
             (get 'page-id attr-list)))
       (filter
        (lambda (te)
          (let ((attr-list (new-element-attributes te)))
            (and 
              (eq? 'leno-element (new-element-tag te))                        ; leno-element, in contrast to theme-text etc. 
              (equal? "title" (defaulted-get 'element-type attr-list #f))     ; title element
              (not (equal? "true" (defaulted-get 'drop attr-list "false")))   ; not dropped 
            )))
        theme-elements)))

(define (find-titles-in-theme theme-elements)
  (map (lambda (te)
          (let* ((attr-list (new-element-attributes te))
                 (lecture-id (get 'lecture-id attr-list))
                 (page-id (get 'page-id attr-list))
                 (element-id  (defaulted-get 'element-id attr-list #f))
                 (element-number (defaulted-get 'element-number attr-list #f))

                 (actual-element-id 
                   (cond (element-id (as-symbol element-id))
                         (element-number (as-number element-number))
                         (else 1)))

                 (el (lookup-element lecture-id page-id "title" actual-element-id))
                )
             (if el (car (element-contents el)) #f)             
          )
       )
       (filter
        (lambda (te)
          (let ((attr-list (new-element-attributes te)))
            (and 
              (eq? 'leno-element (new-element-tag te))                        ; leno-element, in contrast to theme-text etc. 
              (equal? "title" (defaulted-get 'element-type attr-list #f))     ; title element
              (not (equal? "true" (defaulted-get 'drop attr-list "false")))   ; not dropped 
            )))
        theme-elements)))

; Find and return the theme (chapter) page-id in theme-elements
(define (find-chapter-page-id-in theme-elements)
  (let ((section-title-element 
          (find-in-list (lambda (te)
                          (let ((attr-list (new-element-attributes te)))
                            (equal? "section-title" (defaulted-get 'element-type attr-list #f))))
                        theme-elements)))
    (if section-title-element
        (let ((attr-list (new-element-attributes section-title-element)))
          (get 'page-id attr-list))
        #f)))
         


; -----------------------------------------------------------------------------------------------------------
; UNDERLYING ELEMENT MACHINERY:

(define (make-element name rest)
 (let* ((contents-attributes (sort-element-parameters rest name))
        (contents (car contents-attributes))
        (attributes (cdr contents-attributes))
       )
  (let ((es (make-element-structure name contents attributes)))
    (check-element! es)
    es)))


; -------------------------------------------------------------------------------------------------
; The XML-in-LAML parameter handling - inspirred by the HTML4.0 surface mirror.

(define (sort-element-parameters parameters tag-name)
 (let ((res (sort-element-parameters-1 parameters parameters '() '() tag-name)))
   res))

(define (sort-element-parameters-1 original-parameters parameters contents attributes tag-name)
  (cond ((null? parameters) (cons (reverse contents) (reverse attributes)))
        ((or (string? (car parameters)) (list? (car parameters)))
                 (sort-element-parameters-1 original-parameters 
                                        (cdr parameters) (cons (car parameters) contents) attributes tag-name))
        ((and (symbol? (car parameters)) (not (null? (cdr parameters))))
           (let ((attr-name (car parameters))
                 (attr-val (cadr parameters)))
             (sort-element-parameters-1 original-parameters (cddr parameters) contents (cons (cons attr-name attr-val) attributes) tag-name)))
        ((symbol? (car parameters)) (sort-error (string-append "Attributes of the " (as-string tag-name)
                                    " tag must be of the form 'symbol \"value\". Only the symbol " (as-string (car parameters))
                                    " appears in last attribute")  original-parameters))
        (else (sort-error (string-append "Error in element " (as-string tag-name) " tag. Unknown constituent: "
                                          (as-string (car parameters)) ) original-parameters))
  ))

(define (sort-error message parameters)
 (let* ((max-str-lgt 80)  ; symbolic constant definition
        (parameters-1 (as-quoted-string parameters))
        (parameters-2 (if (> (string-length parameters-1) max-str-lgt) 
                        (string-append (substring parameters-1 0 (- max-str-lgt 1)) "...")
                        parameters-1)))
  (error
    (string-append
      message (as-string #\newline)
      "  FORM CONTENTS AND ATTR.: " parameters-2 (as-string #\newline)))))

; ------------------------------------------------------------------------------------------------------
; BASIC ELEMENT CONSTRUCTOR, ACCESSORS, AND PREDICATE.

; Make a normalized element structure (list). Name is the name of the element (either a string or symbol).
; contents is a list of contents forms, each on normalize form.
; attributes is an association list of attributes (key value pairs).
(define (make-element-structure name contents attributes)
  (list 'element name contents attributes))

(define (element-structure? x)
  (and (list? x) (= (length x) 4) (eq? (car x) 'element)))

(define new-element-tag second)
(define new-element-contents third)
(define new-element-attributes fourth)

; ---------------------------------------------------------------------------------------------------
; ELEMENT SURFACE CHECKING.  - To come.

; Check that the element structure  is valid.
; Stop the program if not.
(define (check-element! es)
  #t)


; ---------------------------------------------------------------------------------------------------
; Necessary pre lecture-notes-kernel definitions.
; Some of these have only temporary values to ease early development.

(define note-source-directory (startup-directory))

(define page-name (source-filename-without-extension))

; which lecture - relevant for the author if there were more chapters
; (define current-lecture 1)  ; deleted Nov 20, 2002.

; Do not show lecture numbers - there is only one
(define lecture-number #f)

(define (cross-reference-location-hints location-list)  ; No location hints 
  "")

(define (meta-tag-clauses)
   (list (list 'http-equiv "Content-Type" 'content "text/html; charset = ISO-8859-1")  
         (list 'name "Generator" 'content "LAML")
         (list 'name "description" 
                     'lang (meta-language language-preference)
                     'content note-contents-description)
   )
)

(define front-index? #f)  ; No front index; not needed because there is only one chaper.

; ---------------------------------------------------------------------------------------------------

(load (leno-software-dir-file "lecture-notes-kernel.scm"))   
(if bibtex-support? (load (string-append laml-dir "tools/bibtex/bibtex.scm")))

(define theme-id lecture-id)  ; should really be themes-id

; Redefinition - slightly darker concept boxes in themes. Better for readability of printed versions. 
(define (concept-background-color)
   (if (eq? themes-presentation-medium 'paper)  (make-color 13 46 202) (make-color 6 22 96)))

; ---------------------------------------------------------------------------------------------------



(define (standard-theme ttl bdy)
 (let ((bdy (con (a-name "theme_top") (theme-header) bdy (theme-footer) (theme-vertical-end-space)))
       (prev (if (previous-global-themes-page) (previous-global-themes-page) #f))
       (next (if (next-global-themes-page) (next-global-themes-page) #f))
      )


   (if java-scripting
       (page-with-keypress-script
        ttl
        '()
        bdy

        javascript-loading
        (list (string-append leno-software-directory "javascript/") "lenonavigate.js")
        (js-call "lenoNavigate" 
                 (append
                  (map string-it-single 
                       (list (if prev (apply theme-url prev)  "")
                             (if next (apply theme-url next) "")
                             (html-file top-level-theme-index-file-name) 
                             ""
                             "" "" ""
                  ))
                  (list ) )) 

        theme-background-color black black black
        'double-press
        (actual-stylesheets #t)  ; force use of style sheets for themes. Not central yet. Only used for very few theme forms.
        (leno-css-class 'theme)
        )

       (let ((body-attributes (list 
                               'bgcolor (rgb-color-encoding theme-background-color)
                               'text (rgb-color-encoding black)
                               'link (rgb-color-encoding black)
                               'vlink (rgb-color-encoding black)))
             (underline-suppress (style 'type "text/css" "A {text-decoration: \"none\";}"))

            )
         (html
          (head (title ttl) (if (eq? themes-presentation-medium 'paper) underline-suppress "")
                (link 'href "stylesheets/stylesheet.css" 'rel "stylesheet" 'title "stylesheet" 'type "text/css") ; hack Feb 22, 2008
          )
          (body bdy body-attributes)))


   )))


(define (theme-vertical-end-space) (vertical-space 28))
  
(define (as-theme-text txt)
  (if apply-css-styling?
      txt
      (font-size theme-font-size txt)))


(define (previous-next-navigation)
 (let ((prev (previous-global-themes-page))
       (next (next-global-themes-page))
      )
  (con

      (a-tag (html-file top-level-theme-index-file-name)
             (img-LN "nav-up.gif" 
                     (key-shortcut (text-choice "Thema indholdsfortegnelse" "Theme index") "u")))
      (space 2)
      (if prev 
          (a-tag (string-append (apply theme-name prev) ".html")
                 (img-LN "nav-left.gif" 
                         (key-shortcut (text-choice "Forrige tema i denne lektion" "Previous theme in this lecture") "p")))
          (img-LN "nav-left-empty.gif" ""))
      (space 2)
      (if next 
          (a-tag (string-append (apply theme-name next) ".html") 
                 (img-LN "nav-right.gif" (key-shortcut (text-choice "Næste slide i denne lektion" "Next slide in this lecture") "n")))
          (img-LN "nav-right-empty.gif" ""))
    )))

(define (theme-header)
 (let ((banner (left-middle-right-banner 
		(previous-next-navigation)
		""
		(font-1 4 grey1 (b (lecture-title-given-lecture-id (original-lecture-id theme-id))))
		)))
   (if (eq? themes-presentation-medium 'web)
       (if (and (not (empty-string? news-flash-string)) (>= news-flash-level 2))
	   (div banner
		(leno-news-flash 3 (- preferred-theme-page-width 40)))
	   banner)
       "")))

(define (theme-footer)
 (if (eq? themes-presentation-medium 'web)
  (div (left-middle-right-banner 
	(when-generated) "" (previous-next-navigation)))
  ""))



(define (original-lecture-id theme-id)
 (let* ((theme-id-string (as-string theme-id))
        (pos (substring-index theme-id-string 0 "_themes")))
  (if pos
      (as-symbol (substring theme-id-string 0 pos))
      (laml-error "original-lecture-id: Cannot locate the original lecture id from the theme lecture id: " theme-id))))

; Return the current theme number.
; In the future we may want to enumerate the themes globally, accross a number of underlying lectures
(define (current-theme-number)
  theme-page-number)

; Return a list of number and subnumber
(define (current-theme-sub-number)
  (list (current-theme-number) theme-sub-number))
   

; ---------------------------------------------------------------------------------------------------
; THEME ELEMENT PROCESSING: theme-text and leno-element until further

(define (present-theme-element tag contents attributes)
 (let ((processing-procedure (find-theme-processor tag))
       (drop? (as-boolean (defaulted-get 'drop attributes #f))))
   (if (not drop?)
       (processing-procedure contents attributes)
       "")))

(define (find-theme-processor kind)
  (cond ((eq? kind 'leno-element) theme-leno-element)
        ((eq? kind 'theme-text) theme-theme-text)
        ((eq? kind 'theme-side-box) theme-theme-side-box)
        ((eq? kind 'theme-index-table) theme-theme-index)
        (else (laml-error "Cannot find theme processor function: " (as-string kind)))))


(define (theme-theme-text contents attributes)
 (let ((concatenated-contents (apply string-append contents)))
  (if (> theme-verbosity 1) (display-message "  theme-text" " " (contents-part concatenated-contents 50)))
  (con 
    concatenated-contents
    (p))))

; New version below. The commented-out version does not render well in MS Word.
; (define (theme-theme-side-box contents attributes)
;  (let* ((ttl (get 'title attributes))
;         (id  (get 'id attributes))
;         (concatenated-contents (apply string-append contents))
;         (faked-attributes (list (cons 'lecture-id (original-lecture-id theme-id))   ; faked: the reference does not come from kernel el.
;                                 (cons 'page-id "no-page")
;                                 (cons 'element-type "side-box")
;                                 (cons 'element-id id)))
;        )
;   (set! side-box-sub-number (+  side-box-sub-number 1))
;   (set! ref-caption-map (cons (make-ref-map-entry faked-attributes theme-page-number side-box-sub-number) ref-caption-map))
;   (if (> theme-verbosity 1) (display-message "  theme-side-box" " " (contents-part concatenated-contents 50)))
;   (set! ref-info-list 
;           (cons (make-ref-entry current-theme-page-name (original-lecture-id theme-id) "no-page" "side-box" id #f) ref-info-list))
;   (div 'css:margin-left "10%" 'css:margin-right "10%"
;        'css:margin-bottom "0.7cm"
;        'css:background (rgb-color-encoding 220 220 220)
;        'css:border-width "thin"
;        'css:border-color "black"
;        'css:border-style "solid"
;        'css:padding-left "10px" 'css:padding-right "10px"
; 
;        (pp-ref-pars (original-lecture-id theme-id) "no-page" "side-box" id #f)
;        (a-name (theme-ref-anchor (original-lecture-id theme-id) "no-page" "side-box" id))
;        (left-right-banner (h3 ttl) 
;                           (span 'css:font-family "lucida console" 'css:font-size "small" (b "FOCUS BOX" (current-side-box-number)))) 
;        concatenated-contents)))

; A version with table - for the sake of MS Word rendering.
(define (theme-theme-side-box contents attributes)
 (let* ((ttl (get 'title attributes))
        (id  (get 'id attributes))
        (concatenated-contents (apply string-append contents))
        (faked-attributes (list (cons 'lecture-id (original-lecture-id theme-id))   ; faked: the reference does not come from kernel el.
                                (cons 'page-id "no-page")
                                (cons 'element-type "side-box")
                                (cons 'element-id id)))
        (bg-color (rgb-color-encoding (rgb-color-encoding 220 220 220)))
       )
  (set! side-box-sub-number (+  side-box-sub-number 1))
  (set! ref-caption-map (cons (make-ref-map-entry faked-attributes theme-page-number side-box-sub-number) ref-caption-map))
  (if (> theme-verbosity 1) (display-message "  theme-side-box" " " (contents-part concatenated-contents 50)))
  (set! ref-info-list 
          (cons (make-ref-entry current-theme-page-name (original-lecture-id theme-id) "no-page" "side-box" id #f) ref-info-list))
  (div
    'css:margin-left "5%" 'css:margin-right "5%"
    'css:margin-bottom "0.7cm"
    (pp-ref-pars (original-lecture-id theme-id) "no-page" "side-box" id #f)
    (a-name (theme-ref-anchor (original-lecture-id theme-id) "no-page" "side-box" id))
    (table 'css:border-width "thin"
           'css:border-color "black"
           'css:border-style "solid" 'border "1"
	   (tr (td 'width "*" 'bgcolor bg-color 
		    (left-right-banner (h3 ttl) 
				       (span 'css:font-family "lucida console" 'css:font-size "small" (b "FOCUS BOX" (current-side-box-number))))
		    concatenated-contents))
	   )
    )
))

(define (contents-part str n)
  (let ((lgt (string-length str)))
    (if (< n lgt)
        (string-append (substring str 0 (min lgt n) ) "...")
        (substring str 0 (min lgt n) ))))

(define (display-warning . messages)
  (display
   (string-append
    "Warning: "
    (list-to-string (map as-string messages) " ")))
  (newline))

(define pending-exercise-hr? #f)

(define (theme-leno-element contents theme-leno-attributes)
  (if (> theme-verbosity 1) (display-message (string-append "  leno-element:" (as-string (get 'element-type theme-leno-attributes)))))
  (let* ((lect-id (as-symbol (get 'lecture-id theme-leno-attributes))) ; extract information from theme-leno-attributes
         (pg-id (as-symbol (get 'page-id theme-leno-attributes)))
         (el-type (as-symbol (get 'element-type theme-leno-attributes)))
         (element-id  (defaulted-get 'element-id theme-leno-attributes #f))
         (element-number (defaulted-get 'element-number theme-leno-attributes #f))

         (actual-element-id 
          (cond (element-id (as-symbol element-id))
                (element-number (as-number element-number))
                (else 1)))

         (original-element 
          (lookup-element lect-id pg-id el-type actual-element-id)) ; read element from -.lsp file

         (author-ref-help-entry (make-ref-entry current-theme-page-name lect-id pg-id el-type element-id element-number))
        )
    
    ; Put a ref-entry on the ref-info-list.
    ; This list helps us generate theme refs for cross reference purposes 
    (set! ref-info-list 
          (cons author-ref-help-entry ref-info-list))

    (let ((leno-element-presentation
            (if original-element
                (let ((presentation     ; form presentation
                       (present-theme-subelement
                        (element-tag original-element) ; original selector
                        (element-contents original-element) ; original selector
                        (element-attributes original-element)
                        theme-leno-attributes
                        )))
                  (con 
                   presentation
                   (p)))
                (begin
                  (laml-error "Cannot locate leno-element: " lect-id pg-id el-type actual-element-id)   ; should be fatal error
                  ""))))
       (if (and pending-exercise-hr? (not (eq? (as-symbol el-type) 'exercise)))  ; end of exercises - make trailing hr
           (begin
             (set! pending-exercise-hr? #f)
             (con (hr) leno-element-presentation)
           )
           leno-element-presentation))

    ))

(define (present-theme-subelement kind original-contents original-attributes theme-leno-attributes)
  (let ((processing-procedure (find-theme-subclause-processor kind)))
    (processing-procedure original-contents (append theme-leno-attributes original-attributes))))

; Return a presentation of the parts (sections) in this theme. A table.
; Relies on the two global variables, collected by do-theme. Does not rely on its parameters!
(define (theme-theme-index contents attributes) 
 (if (eq? themes-presentation-medium 'web)
  (let* ((entries 
          (map 
           (lambda (page-id title n)
             (if (and page-id title)
                 (con (as-string (current-theme-number)) "." (as-string n) (space 1)
                          (a 'href (string-append "#" (theme-ref-anchor (original-lecture-id lecture-id) page-id "title" 1)) title)) 
                 "???" ))
           section-page-ids-in-theme
           section-titles-in-theme
           (number-interval 1 (length section-page-ids-in-theme)) 
        ))
        (sublisted-entries (sublist-by-2columns entries ""))
       )
   (indent-pixels 10
    (table-3 0
      (list "350" "350")
      sublisted-entries)))
  ""))



; ---------------------------------------------------------------------------------------------------
; THEME PRESENTATION OF NOTE PAGE CLAUSES:

; The dispatcher that returns the rendering function for the leno-element subclause of a theme clause.
(define (find-theme-subclause-processor kind)
 (cond 
  ((eq? kind 'title) theme-style-title)
  ((eq? kind 'text) theme-style-text)
  ((eq? kind 'items) theme-style-items)
  ((eq? kind 'point) theme-style-point)
  ((eq? kind 'program) theme-style-program)
  ((eq? kind 'source-program) theme-style-source-program)
  ((eq? kind 'image) theme-style-image)
  ((eq? kind 'concepts) theme-style-concepts)
  ((eq? kind 'example) theme-style-example)
  ((eq? kind 'opposing) theme-style-opposing)
  ((eq? kind 'comment) theme-style-comment)
  ((eq? kind 'language-syntax) theme-style-syntax)
  ((eq? kind 'slide-space) theme-style-slide-space)
  ((eq? kind 'tabular) theme-style-tabular)
  ((eq? kind 'note-text) theme-style-note-text)
  ((eq? kind 'slide-text) theme-style-slide-text)
  ((eq? kind 'cross-references) theme-style-cross-references)
  ((eq? kind 'exercise) theme-style-exercise)
  ((eq? kind 'long-slide) empty-slide-element)
  ((eq? kind 'index-words) empty-slide-element)
  ((eq? kind 'image-series) theme-style-image-series)
  ((eq? kind 'section-title) theme-style-section-title)
  ((eq? kind 'slide-image) theme-style-slide-image)
  ((eq? kind 'concept-list) theme-style-concept-list)
  ((eq? kind 'applet-program) theme-style-applet-program)
  ((eq? kind 'synopsis) theme-style-synopsis)
  ((eq? kind 'quotation) theme-style-quotation)
  ((eq? kind 'quiz) theme-style-quiz)
  ((eq? kind 'show-and-speak) empty-slide-element)
  ((eq? kind 'lecturer-photos) theme-style-lecturer-photos)
  ((eq? kind 'lecturer-photos-and-logo) theme-style-lecturer-photos-and-logo) 
  ((eq? kind 'elucidate) theme-style-elucidate)
  ((eq? kind 'elucidator-program-fragment) theme-style-elucidator-program-fragment)
  ((eq? kind 'side-track) theme-style-side-track)
  ((eq? kind 'svg-image) theme-style-svg-image)
  ((eq? kind 'flash-image) theme-style-flash-image)
  ((eq? kind 'meta-text) theme-style-meta-text)
  ((eq? kind 'theme-text) theme-style-theme-text)

  ((eq? kind 'splice-page-with) theme-style-splice-page-with)
  ((eq? kind 'splice-page-without) theme-style-splice-page-without)
  (else (error (string-append "Cannot find leno-element theme processor function: " (as-string kind))))))



(define (presentation-slice anchor-name main-text annotation-text attributes)
 (let* ((el-type (defaulted-get 'element-type attributes #f))
        (annotation-presentation 
           (if el-type 
               (as-symbol (defaulted-get 'annotations attributes (default-annotation-handling el-type)))
               'ignore  ; only applies for reference section
           ) 
        ))
               
   (cond ((and (eq? annotation-presentation 'keep) (not (blank-string? annotation-text)))
          (con
            anchor-name (pp-ref attributes)
            main-text (p)
            (indent-pixels 10 (font-size 2 (em annotation-text)))))

         ((and (eq? annotation-presentation 'keep) (blank-string? annotation-text))
           (con anchor-name (pp-ref attributes) main-text))

        ((and (eq? annotation-presentation 'unfold-before) (not (blank-string? annotation-text)))
          (con anchor-name (pp-ref attributes)
               annotation-text (p)
               main-text))

        ((and (eq? annotation-presentation 'unfold-before) (blank-string? annotation-text))
          (con anchor-name (pp-ref attributes) main-text))
            
        ((and (eq? annotation-presentation 'unfold-after) (not (blank-string? annotation-text)))
           (con anchor-name (pp-ref attributes) main-text (p)
               annotation-text))

        ((and (eq? annotation-presentation 'unfold-after)  (blank-string? annotation-text))
           (con anchor-name (pp-ref attributes) main-text))

        ((eq? annotation-presentation 'ignore)
           (con anchor-name (pp-ref attributes) main-text))

        ((eq? annotation-presentation 'merge)  ; annotations merged with main text - only applies for 'items'
           (con anchor-name (pp-ref attributes) main-text))

        (else (laml-error "presentation-slice in lecture-notes-theme: " 
                 "Unknown kind of annotation presentation in " (as-string el-type) ": "  annotation-presentation)))))



(define (theme-style-title original-contents attributes)
 (set! theme-sub-number (+ 1 theme-sub-number))

 (let* ((on-cond (lambda (x y) (if x y "")))
        (title (car original-contents))
        (orig-lect-id (original-lecture-id theme-id))
        (comment (if (> (length original-contents) 1) (cadr original-contents) ""))
        (slide-lecture-id (get 'lecture-id attributes))
        (slide-page-id (get 'page-id attributes))

        (prev-section-page-id (find-previous-section-page-id slide-page-id section-page-ids-in-theme)) ; not used any more
        (prev-aux1-entry (find-previous-chapter-section-page-id 'title orig-lect-id slide-page-id))

        (next-section-page-id (find-next-section-page-id slide-page-id section-page-ids-in-theme))     ; not used any more
        (next-aux1-entry (find-next-chapter-section-page-id 'title orig-lect-id slide-page-id))

        (sub-num-list (current-theme-sub-number))
        (sound (speak-name orig-lect-id slide-page-id 'slide-part 1))
        (aux1-entry (make-aux1-entry 'title title (as-string slide-lecture-id) (as-string chapter-page-id) (as-string slide-page-id) (first sub-num-list) (second sub-num-list)))
       )
   (set! ref-caption-map (cons (make-ref-map-entry attributes theme-page-number (second sub-num-list)) ref-caption-map))

   ; Add aux1-entry for non-dropped title elements:   
   (if (not (equal? "true" (defaulted-get 'drop attributes "false")))
       (set! aux1-list (cons aux1-entry aux1-list)))

   (con (vertical-space 1)
    (presentation-slice 
     (a-name (theme-ref-anchor-from-attributes attributes))
     (con 
      (theme-title-line sub-num-list title) (br)
      (if (eq? themes-presentation-medium 'web)
          (font-size 1 
                     (con
                          (a-tag "theme-index.html"                          ;  Earlier: (contents-url orig-lect-id) 
                                 (font-color grey (text-choice "Indhold" "Contents")) ) (space 3)

                          (if chapter-page-id     ; should always be true
                              (a-tag (string-append "#" "theme_top")                 ;  Alternatively:   (theme-ref-anchor orig-lect-id chapter-page-id "section-title" 1)
                                          (font-color grey (text-choice "Op" "Up")))
                              (font-color grey2 (text-choice "Op" "Up")))   
                          (space 1)
                          (if prev-aux1-entry  ;  prev-section-page-id
                             (a-tag (string-append (html-file (theme-name (theme-name-of (lecture-id-of-aux1-entry prev-aux1-entry)) (section-id-of-aux1-entry prev-aux1-entry)))
                                                    "#" (aux1-anchor prev-aux1-entry))   ; (theme-ref-anchor orig-lect-id prev-section-page-id "title" 1)
                                          (font-color grey (text-choice "Forrige" "Previous")))
                             (font-color grey2 (text-choice "Forrige" "Previous"))
                          )
                          (space 1)
                          (if next-aux1-entry ;  next-section-page-id
                             (a-tag (string-append (html-file (theme-name (theme-name-of (lecture-id-of-aux1-entry next-aux1-entry)) (section-id-of-aux1-entry next-aux1-entry)))
                                                  "#" (aux1-anchor next-aux1-entry))  ; (theme-ref-anchor orig-lect-id next-section-page-id "title" 1)
                                   (font-color grey (text-choice "Næste" "Next")))
                             (font-color grey2 (text-choice "Næste" "Next")))

                          (space 3)

                          (on-cond make-slide-view? 
                             (con (a-tag (slide-url orig-lect-id slide-page-id) (font-color grey "Slide")) (space 1)))
                          (on-cond make-annotated-slide-view? 
                             (con (a-tag (note-url orig-lect-id slide-page-id) 
                                         (font-color grey (text-choice "Annoteret slide" "Annotated slide"))) (space 1)))
                          (on-cond make-aggregated-view?
                             (con (a-tag (book-url orig-lect-id slide-page-id) 
                                         (font-color grey (text-choice "Aggregerede slides" "Aggregated slides"))) (space 1)))

                          (space 3)

                          (if show-and-speak?
                              (if (file-exists-robust? (sound-file-path sound))
                                  (con (a-tag (speak-url sound) (font-color grey (text-choice "Tale" "Speak"))) (space 1))
                                  "")
                              "")
                          (a-tag (all-word-index-url orig-lect-id) (font-color grey (text-choice "Stikord" "Subject index"))) (space 1) 
                          (on-cond do-program-linking-in-themes?
                                  (con (a-tag (string-append (source-program-index-name orig-lect-id) ".html") (font-color grey (text-choice "Programindeks" "Program index"))) (space 1)))
                          (on-cond do-exercise-linking-in-themes? 
                                  (con (a-tag (string-append (exercise-index-name orig-lect-id) ".html") (font-color grey (text-choice "Opgaveindeks" "Exercise index"))) (space 1)))
                          (br)
                          ))
          (a-tag (slide-url orig-lect-id slide-page-id)
                 (font-1 1 black (lecture-and-page-information (as-symbol slide-lecture-id) (as-symbol slide-page-id))))
          )
      )
     (con  comment (p))
     attributes
     ))
 ))

; Find the page-id previous to current-page-id within the list page-id-list.
(define (find-previous-section-page-id current-page-id page-id-list)
  (element-before current-page-id page-id-list id-1 equal?))

; Find the page-id after current-page-id within the list page-id-list.
(define (find-next-section-page-id current-page-id page-id-list)
  (element-after current-page-id page-id-list id-1 equal?))
  

; return the numbered title line. sub-num-list is a list, length 2, of (number subnumber).
(define (theme-title-line sub-num-list title)
 (font-1 5 black (con (as-string (first sub-num-list)) "." (as-string (second sub-num-list)) "." (horizontal-space 2) title)))


(define (theme-style-text original-contents attributes)
 (let ((text (car original-contents))
       (comment (if (> (length original-contents) 1) (cadr original-contents) "")))
   (presentation-slice 
     (a-name (theme-ref-anchor-from-attributes attributes))
     (con (indent-pixels 10 (note-text-left text)) (p))
     (con  comment (p))
     attributes
)))


(define (theme-style-items original-contents attributes)
 (letrec ((items-of-item      (lambda (item-el)
                                (third (element-contents item-el))))
          (item-list-of-items (lambda (items-el)
                                (element-contents items-el))))

   (let ((annotation-presentation (as-symbol (defaulted-get 'annotations attributes #f)))
         (selection (as-symbol (defaulted-get 'select attributes "all")))
         )
     (if (eq? annotation-presentation 'merge)
         (presentation-slice
          (a-name (theme-ref-anchor-from-attributes attributes))
          (con (indent-pixels theme-box-indent 
                              (color-frame-width
                               (ul-1 (map slide-item-merge-annotations 
                                          (if (eq? selection 'subitems)
                                              (flatten (map (compose item-list-of-items items-of-item) original-contents))
                                              original-contents)))
                               items-box-color
                               (- preferred-theme-page-width (* 2 theme-box-indent)))) (p))
          ""
          attributes
          )
         (presentation-slice
          (a-name (theme-ref-anchor-from-attributes attributes))
          (con (indent-pixels theme-box-indent 
                              (color-frame-width
                               (ul-1 (map slide-item
                                          (if (eq? selection 'subitems)
                                              (flatten (map (compose item-list-of-items items-of-item) original-contents))
                                              original-contents)
                                      )
                               )
                               items-box-color
                               (- preferred-theme-page-width (* 2 theme-box-indent)))) (p))
          (con 
       
           (string-merge
            (map note-item original-contents)
            (make-list (length original-contents) (p)))
           (p))
          attributes
          )
         )
     )
 )
)

; Extracts a slide item from i, and processes subitems recursively.
; String-appends the annotations appropriately. For recursive processing of
; nested items, special-items-theme-style-present which calls this function 
; slide-item-merge-annotations (mutual recursion).
(define (slide-item-merge-annotations i)
  (let* ((ei (expand-item i))
         (main-text (car ei))
         (annotations (cadr ei))
         (raw-sub-items (caddr ei))
         (br-if-non-empt (lambda (x) (if (not (empty-string? x)) (br) "")))
        )
    (if (equal? "" main-text)
        (display-warning "First parameter of an item is empty. Causes problems in some browsers"))
    (if (not (equal? raw-sub-items ""))
        (let ((sub-items (special-items-theme-style-present (element-contents raw-sub-items) (element-attributes raw-sub-items))))
           (con main-text (br-if-non-empt annotations)
                (em (font-size 2 annotations)) (p) sub-items))
        (con main-text (br-if-non-empt annotations) (em (font-size 2 annotations)) (p))
    )))

(define (special-items-theme-style-present items-element attribute)
  (ul-1 (map slide-item-merge-annotations items-element)))
  


(define (theme-style-point original-contents attributes)
 (let ((point (car original-contents))
       (comment (if (> (length original-contents) 1) (cadr original-contents) "")))

  (if (eq? themes-presentation-medium 'web)  ;  apply-css-styling?
      (center (narrow-with-pixels 30 (leno-css-styled 'theme 'point point (aggregated-page-element-id))))
      (con 
       (presentation-slice
        (a-name (theme-ref-anchor-from-attributes attributes))
        (con (note-text-left (center-frame 30 (font-color red (note-text-left point)))) (p))
        (con comment (p))
        attributes
        )
       ))
))



(define (theme-style-program original-contents attributes)
 (let ((program-text (car original-contents))
       (comment (if (> (length original-contents) 1) (cadr original-contents) "")))
  (presentation-slice
     (a-name (theme-ref-anchor-from-attributes attributes))
     (con (indent-pixels 10 (note-text-left (font-size 2 (pre program-text)))) (p))
     (con  comment (p))
     attributes
  )
))

(define (theme-style-source-program original-contents attributes)
 (let* ((program-file-name (first original-contents))
        (mark (second original-contents))
        (colorizing (if black-and-white-edition (enforce-black-and-white (third original-contents)) (third original-contents)))
        (extracted-program-and-doc (program-extract program-file-name mark))
        (program-text 
           (html-protect
             (if extract-and-present-end-of-line-doc-comments
                 (extract-program-source extracted-program-and-doc)
                 extracted-program-and-doc)))
        (documentation-text? (turn-into-boolean (substring-index extracted-program-and-doc 0 end-of-line-doc-comment-prefix)))
        (colorized-program-text (colorize-substrings program-text colorizing))
        (theme-how-to-show (defaulted-get 'theme-mode attributes #f))  ; inline or external
        (drop-program-presentation (as-boolean (defaulted-get 'drop-presentation attributes #f)))
        (how-to-show   ; A mess!
          (if drop-program-presentation
              '()
              (if theme-how-to-show
                  (cond ((equal? theme-how-to-show "inline") (list 'slide-inline))
                        ((equal? theme-how-to-show "external") (list 'slide-external))
                        (else (laml-error "theme-style-source-program: Unknown theme-mode: " theme-how-to-show)))
                  (fourth original-contents))))

        (comment (if (> (length original-contents) 3) (fifth original-contents) ""))
        (initial-sentence (first-sentence-in-string comment))
       )
  (theme-style-source-program-1 program-file-name colorized-program-text how-to-show
                                initial-sentence ; pass comment instead of both main-text and annontation should appear as caption.
                                initial-sentence
                                documentation-text?
                                attributes)))


(define (enforce-black-and-white coloring-list)
  (map (lambda (cde)  ; a color-description-entry
          (cons (car cde)  ; from string
                (cons (cadr cde)   ; to string
                      (cons (rgb-color-encoding black)   ; color - black
                            (cons 'bold           ; face - bold
                                  (if (>= (length cde) 5) (list (fifth cde)) (list 1)))))))
       coloring-list))
      
; The procedure doing the real work of theme-style-source-program. Also used by theme-style-elucidator-program-fragment.
(define (theme-style-source-program-1 program-file-name colorized-program-text how-to-show comment
                                      initial-sentence documentation-text? attributes . optional-parameter-list)
  (let ((context-url (optional-parameter 1 optional-parameter-list #f))
        (el-type (get 'element-type attributes))
        (kind (as-symbol (defaulted-get 'kind attributes 'source-program)))   ; kind is normally a source-program. kind can also be a listing, however.
        (theme-bg-color (defaulted-get 'theme-bg-color attributes #f))

       )
    (let* ((linking-text (text-choice "Link to elucidative program" "Link til elucidativt program"))
           (linking-anchor (if context-url (a-tag-target context-url (font-color note-foreground-color linking-text) "elucidator") ""))
           (annotation-presentation (as-symbol (defaulted-get 'annotations attributes (default-annotation-handling el-type))))
           (hs (horizontal-space 4))
           (number-of-lines (number-of-lines-in-text colorized-program-text))
          )
      (cond ((null? how-to-show)
             (set! program-sub-number (+ program-sub-number 1))
             (set! ref-caption-map (cons (make-ref-map-entry attributes theme-page-number program-sub-number) ref-caption-map))
             "")

            ((eq? annotation-presentation 'caption) ; implies implicitly how-to-show is 'slide-inline
               (set! program-sub-number (+ program-sub-number 1))
               (set! ref-caption-map (cons (make-ref-map-entry attributes theme-page-number program-sub-number) ref-caption-map))
               (presentation-slice
                (a-name (theme-ref-anchor-from-attributes attributes))
                (center
                  (color-frame-with-caption-and-line-numbers
                    (div 'align "left" (pre 'css:font-size program-text-font-size colorized-program-text))   ; (font-size 2 colorized-program-text)
                    (div 'align "left" (pre (line-number-text-column number-of-lines) 'css:font-size program-text-font-size 
                                                                                      'css:color line-number-fg-color))
                    (if theme-bg-color theme-bg-color program-frame-color)
                    line-number-bg-color
                    (caption-part (cond ((eq? kind 'source-program) 'program)
                                        ((eq? kind 'listing) 'listing))
                                  (span comment 
  ;                                    Not possible to finde the program number. Therefore is this idea dropped:
  ;                                    (if (and documentation-text? (eq? themes-presentation-medium 'web))
  ;                                        (a 'href "???" ; (html-file (program-name lecture-id page-id 'note program-number))
  ;                                                 "More explanations.")
  ;                                        "" 
  ;                                    )              
                                  )
                    )
                    comment
                  )
                )
                "" ; no comment - already presented as caption
                (cons (cons 'annotations 'ignore) ; enforce no additional presentation at all of annotations
                      attributes)
                ))

            ((eq? (car how-to-show) 'slide-inline)
              (presentation-slice
               (a-name (theme-ref-anchor-from-attributes attributes))
               (con (indent-pixels 15 (font-size 3 (pre colorized-program-text))) (p))
               (con  (con comment (br) linking-anchor) (p))
               attributes
               ))

            (else
              (let ((file-name (program-name lecture-id page-id 'note program-number))) ;@a
                (set! program-number (+ program-number 1)) ;@b
                (save-note-program colorized-program-text file-name (note-url lecture-id page-id)) ; program saved again,
                                        ; under another name, in another size
                (presentation-slice
                 (a-name (theme-ref-anchor-from-attributes attributes))
                 (con
                  (table-3 0 (list 100 390) 
                           (list 
                            (list (a-tag (string-append file-name ".html")
                                         (img-LN (program-icon-name language-preference 'small) program-file-name))
                                  (note-text-left (font-color grey1 (b initial-sentence))))
                            )
                           "middle") (p))
                 (con  (con comment (br) linking-anchor) (p))
                 attributes
                 )
                ))))))

(define (line-number-text-column n)
  (apply string-append (map (lambda (x) (string-append x CR)) (map as-string (number-interval 1 n)))))

(define (number-of-lines-in-text str)
 (letrec ((number-of-lines-in-text-1
           (lambda (str from res)
             (let ((found-idx (find-in-string str (as-char CR) from)))
               (if found-idx
                   (number-of-lines-in-text-1 str (+ found-idx 1) (+ 1 res))
                   res)))))
  (number-of-lines-in-text-1 str 0 1)))

(define (color-frame-with-caption frame-text frame-color caption-text raw-caption-text)
 (let ((long-caption? (> (string-length caption-text) 100)))
  (table
    (tr (td 'width "*" 'bgcolor (rgb-color-encoding frame-color) frame-text))
    (tr (td 'width "*" 'bgcolor (rgb-color-encoding white) 'align "center"
             (table (color-frame-caption-tr caption-text raw-caption-text)))))))

(define (color-frame-with-caption-and-line-numbers frame-text line-number-text frame-color line-number-color caption-text raw-caption-text)
 (let ((long-caption? (> (string-length caption-text) 100)))
  (table
    (tr (td 'width "15" 'bgcolor (rgb-color-encoding line-number-color) 'valign "top" line-number-text)
        (td 'width "*" 'bgcolor (rgb-color-encoding frame-color) 'valign "top" frame-text))
    (tr (td 'width "15" " ") 
        (td 'width "*" 'bgcolor (rgb-color-encoding white) 'align "center"
                (table (color-frame-caption-tr caption-text raw-caption-text)))))))
      ; 'align "center" added aug 3, 2007 

; caption-text is with markup, raw-caption-text is without:
(define (color-frame-caption-tr caption-text raw-caption-text)
  (let ((caption-length (string-length raw-caption-text)))
    (cond ((< caption-length 50)
            (tr (td 'width "165" "") (td 'width "*" caption-text) (td 'width "165" "")))   ; was 190, and before that 250
          ((<= caption-length 100)
            (tr (td 'width "150" "") (td 'width "*" caption-text) (td 'width "150" "")))
          (else
            (tr (td 'width "50" "") (td 'width "600" caption-text) (td 'width "50" ""))))))

(define (theme-style-image original-contents attributes)
 (let ((image-file (car original-contents))
       (comment (if (> (length original-contents) 1) (cadr original-contents) ""))
      )
    (set! figure-sub-number (+ figure-sub-number 1))
    (set! ref-caption-map (cons (make-ref-map-entry attributes theme-page-number figure-sub-number) ref-caption-map))
    (presentation-slice
     (a-name (theme-ref-anchor-from-attributes attributes))
     (con (center 
            (img-0 (string-append  "." "/" "graphics/small/" image-file))
            (color-frame-width 
             (caption-part 'figure comment) 
             theme-background-color caption-width)
          ) (p))
     ""
     (cons (cons 'annotations 'ignore) attributes)
)))

(define (theme-style-svg-image original-contents attributes)
 (let* ((image-file (car original-contents))   ; can be #f. The name may depend on the page context.  See image file name below.
        (width (if (> (length original-contents) 1) (second original-contents) #f))
        (height (if (> (length original-contents) 2) (third original-contents) #f))
        (comment (if (> (length original-contents) 3) (fourth original-contents) ""))

        (svg-clause-id (if (> (length original-contents) 4) (fifth original-contents) ""))
        (slide-page-id (get 'page-id attributes))
        (image-file-name (if image-file (file-name-proper image-file) (string-append (as-string slide-page-id) "-" svg-clause-id)))

        (reduced-width (as-number (* (as-number width) 0.6)))
        (reduced-height (as-number (* (as-number height) 0.6)))

        (target-dir (string-append note-source-directory (relative-source-html-destination-path-fragment)))
       )
    (set! figure-sub-number (+ figure-sub-number 1))
    (set! ref-caption-map (cons (make-ref-map-entry attributes theme-page-number figure-sub-number) ref-caption-map))

    (let ((svg-image-contribution  
             (object 'width (as-string reduced-width) 'height (as-string reduced-height)
                                           'data (string-append  "." "/" "graphics/" image-file-name "." "svg") 'type "image/svg+xml" ))
          (png-image-contribution 
             (img 'alt "" 'src (string-append  "." "/" "graphics/small/" (file-name-proper image-file-name) "." "png") 'border 0))
         )
      (presentation-slice
       (a-name (theme-ref-anchor-from-attributes attributes))
       (con (center 
             (cond ((eq? treat-svg-as 'svg)
                    (con (center svg-image-contribution)))
                   ((eq? treat-svg-as 'png)
                    (con (center png-image-contribution)))
                   ((and (eq? treat-svg-as 'png-if-exist) 
                       (file-exists? (string-append target-dir "graphics/small/" (file-name-proper image-file-name) "." "png")))
                    (con (center png-image-contribution)))
                   ((and (eq? treat-svg-as 'png-if-exist) 
                         (not (file-exists? (string-append target-dir "graphics/small/" (file-name-proper image-file-name) "." "png"))))
                    (con (center svg-image-contribution)))
                   )   
        
             ; Caption:
             (color-frame-width 
              (caption-part 'figure comment) 
              theme-background-color caption-width)
             ) (p))
       ""
       (cons (cons 'annotations 'ignore) attributes)
       ))))

(define (theme-style-flash-image original-contents attributes)
 (let* ((image-file (car original-contents))
        (width (if (> (length original-contents) 1) (second original-contents) #f))
        (height (if (> (length original-contents) 2) (third original-contents) #f))
        (comment (if (> (length original-contents) 3) (fourth original-contents) ""))

        (reduced-width (as-number (* (as-number width) 0.6)))
        (reduced-height (as-number (* (as-number height) 0.6)))

        (image-file-path (string-append  "." "/" "graphics/" image-file))

       )
    (set! figure-sub-number (+ figure-sub-number 1))
    (set! ref-caption-map (cons (make-ref-map-entry attributes theme-page-number figure-sub-number) ref-caption-map))
    (presentation-slice
     (a-name (theme-ref-anchor-from-attributes attributes))
     (con (center 
            (object 'width (as-string reduced-width) 'height (as-string reduced-height)
                            'classid "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
                            'codebase "http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=5,0,0,0"
                            (param 'name "movie" 'value image-file-path)
                            (param 'name "quality" 'value "high")
                            (param 'name "salign" 'value "T")
                                        ;bgcolor ?
                            (free-html-element "embed" 
                                               'src image-file-path
                                               'type "application/x-shockwave-flash" 
                                               'pluginspage "http://www.macromedia.com/shockwave/download/index.cgi?P1_Prod_Version=ShockwaveFlash")
                            )
            (color-frame-width 
             (caption-part 'figure comment) 
             theme-background-color caption-width)
          ) (p))
     ""
     (cons (cons 'annotations 'ignore) attributes)
     )))

; Return a caption line. Kind is either the symbol program, figure, syntax, table, ...
(define (caption-part kind txt)
 (let ((init-text (cond ((eq? kind 'program) (text-choice "Program" "Program"))
                        ((eq? kind 'listing) (text-choice "Listning" "Listing"))
                        ((eq? kind 'syntax) (text-choice "Syntaks" "Syntax"))
                        ((eq? kind 'figure) (text-choice "Figur" "Figure"))
                        ((eq? kind 'table) (text-choice "Tabel" "Table"))
                        ((eq? kind 'concepts) (text-choice "Begreb" "Concept"))
                        (else (laml-error "caption-part: Unknown kind: " kind))))
       (num-text  (cond ((eq? kind 'program) (current-program-number))
                        ((eq? kind 'listing) (current-program-number))    ; listing a programs share numberings 
                        ((eq? kind 'syntax) (current-syntax-number))
                        ((eq? kind 'figure) (current-figure-number))
                        ((eq? kind 'table) (current-table-number))
                        ((eq? kind 'concepts) (current-concepts-number))
                        (else (laml-error "caption-part: Unknown kind: " kind))))
       (hs (horizontal-space 4))
      )
  (font-size 2 (con init-text " " num-text hs (em txt)))))



(define (theme-style-concepts original-contents attributes)
  (presentation-slice
     (a-name (theme-ref-anchor-from-attributes attributes))
     (con (note-text-left 
            (center-frame-color 30 (concept-background-color)
             (apply string-append
               (map (lambda (x) (con (p) (font-color white x)))
                    (map note-text-left (map slide-item original-contents)))))) (p))
     (con 
       (string-merge
                (map note-item original-contents)
                (make-list (length original-contents) (p)))
       (p))
     attributes
))


(define (theme-style-concept-list original-contents attributes)
 (let ((real-concept-list (map element-contents original-contents)))
  (presentation-slice
     (a-name (theme-ref-anchor-from-attributes attributes))
     (con (note-text-left 
            (center-frame-color 30 (concept-background-color)
             (apply string-append
               (map (lambda (x) (con (p) (font-color white x)))
                    (map note-text-left (map emphasize-concept-name real-concept-list))))

            )
          ) 
       (p))
     (con 
       (string-merge
                (map concept-explanation real-concept-list)
                (make-list (length real-concept-list) (p)))
       (p))
     attributes
)))

(define (theme-style-example original-contents attributes)
 (let ((the-example (car original-contents))
       (about-the-example (if (> (length original-contents) 1) (cadr original-contents) "")))
   (presentation-slice
     (a-name (theme-ref-anchor-from-attributes attributes)) 
     (con (indent-pixels 10 (i (note-text-left the-example))) (p))
     (con  about-the-example (p))
     attributes
   )))

(define (theme-style-opposing original-contents attributes)
 (presentation-slice
   (a-name (theme-ref-anchor-from-attributes attributes))
   (table-1 0 (list "*" 40 "*") (make-list 3 slide-background-color)
      (map (lambda (a1-a2) (list (note-text-left (slide-item a1-a2)) "" (note-text-left (note-item a1-a2)))) original-contents))
   ""
   attributes
))

(define (theme-style-comment original-contents attributes)
   (let ((comment (car original-contents)))
   (presentation-slice
     (a-name (theme-ref-anchor-from-attributes attributes)) 
     (con (text-choice "Intern kommentar: " "Internal comment: ")  (i (note-text-left comment)) (p))
     ""
     attributes
)))


(define (theme-style-syntax original-contents attributes)
 (let* ((syntax-form (car original-contents))
        (syntax-form-1 (string-append CR syntax-form))
        (comment (if (> (length original-contents) 1) (cadr original-contents) ""))
        (el-type (get 'element-type attributes))
        (annotation-presentation (as-symbol (defaulted-get 'annotations attributes (default-annotation-handling el-type))))
       )
  (cond ((eq? annotation-presentation 'caption)
           (set! syntax-sub-number (+  syntax-sub-number 1))
           (set! ref-caption-map (cons (make-ref-map-entry attributes theme-page-number syntax-sub-number) ref-caption-map))

           (presentation-slice
            (a-name (theme-ref-anchor-from-attributes attributes))
            (con 
             (center 
              (con
               (color-frame-with-caption 
                (center (color-frame (div 'align "left" (pre (font-size 2 syntax-form-1))) syntax-frame-color)) 
                theme-background-color
                (caption-part 'syntax comment)
                comment
                )
               )


                                        ;         (con (color-frame (pre (font-size 2 syntax-form-1)) syntax-frame-color)
                                        ;              (color-frame-width 
                                        ;             (caption-part 'syntax comment) 
                                        ;             theme-background-color caption-width)
                                        ;         )
              )
             (p)
             )
            ""
            (cons (cons 'annotations 'ignore) attributes))
        )
        (else 
          (presentation-slice
           (a-name (theme-ref-anchor-from-attributes attributes))
           (con (indent-pixels theme-box-indent (color-frame (pre (font-size 2 syntax-form-1)) syntax-frame-color)) (p))
           (con  comment (p))
           attributes)))))


(define (theme-style-slide-space original-contents attributes)
   "")

(define (theme-style-tabular original-contents attributes) ; border column-widths list-of-list . comment
 (let* ((border (first original-contents))
        (column-widths (second original-contents))
        (list-of-list (third original-contents))
        (com (if (> (length original-contents) 3) (fourth original-contents) ""))
        (el-type (get 'element-type attributes))
        (annotation-presentation (as-symbol (defaulted-get 'annotations attributes (default-annotation-handling el-type))))
       )
   (set! table-sub-number (+  table-sub-number 1))

  (cond ((eq? annotation-presentation 'caption)
          (set! ref-caption-map (cons (make-ref-map-entry attributes theme-page-number table-sub-number) ref-caption-map))
          (presentation-slice
           (a-name (theme-ref-anchor-from-attributes attributes))
           (center
            (con
             (table 
              'border (as-string border)
              (map
               (lambda (row)
                 (tr (map (lambda (cell width)
                            (td 'width (as-string width) 'align "left" 'bgcolor (rgb-color-encoding table-cell-color) (font-size 3 (as-string cell))))
                          row column-widths)))
               list-of-list))
             
             (color-frame-width 
              (caption-part 'table com) 
              theme-background-color caption-width) 
             (p)))
           ""
           (cons (cons 'annotations 'ignore) attributes)
           ))
        (else 
          (presentation-slice
           (a-name (theme-ref-anchor-from-attributes attributes))
           (con
            (indent-pixels theme-box-indent
                           (table-1 border
                                    column-widths
                                    (make-list (length column-widths) table-cell-color)
                                    (map (lambda (row) (map (lambda (el) (font-size 3 el)) row)) list-of-list))) (p))
           (con  com (p))
           attributes
           )
         ))))

(define (theme-style-slide-text original-contents attributes)
  (let ((text (first original-contents))
        (comment ""))
   (presentation-slice
     (a-name (theme-ref-anchor-from-attributes attributes)) 
     text
     (con  comment (p))
     attributes
)))

(define (theme-style-note-text original-contents attributes)
  (let ((text "")
        (comment (first original-contents)))
   (presentation-slice
     (a-name (theme-ref-anchor-from-attributes attributes)) 
     text
     (con  comment (p))
     attributes
)))

(define (theme-style-meta-text original-contents attributes)
  (let* ((text "")
        (comment (first original-contents))
        (type (second original-contents))
        (icon (if (equal? (as-string type) "readers-guide") 
                  (img-LN (readers-guide-icon-name language-preference)
                          "")
                  ""))
        (icon-contribution 
          (if (empty-string? icon) "" (con icon (br))))

       )
   (presentation-slice
     (a-name (theme-ref-anchor-from-attributes attributes)) 
     text
     (con icon-contribution (em comment) (p))
     attributes
)))

(define (theme-style-theme-text original-contents attributes)
 (let* ((text (first original-contents))
       )
   (presentation-slice
     (a-name (theme-ref-anchor-from-attributes attributes)) 
     text
     ""
     attributes)
))


(define (theme-style-cross-references original-contents attributes)
 (let ((list-of-cross-refs (first original-contents)))
  (set! theme-cross-reference-list (append theme-cross-reference-list list-of-cross-refs))
  ""))


; keeps the original numbering of exercises, as found in lecture-notes pages.
; July 4, 2008: Now with revealing of solution - which was very, very tricky to dig out. 
(define (theme-style-exercise original-contents attributes) ;   id-symbol title formulation-clause . solution-clause
 (let* ((exercise-id-symbol (first original-contents))
        (title (second original-contents))
        (formulation-clause (third original-contents))
        (solution-clause (fourth original-contents))
        (slide-page-id (get 'page-id attributes))
        (slide-lecture-id (get 'lecture-id attributes))
        (exercise-info-list (exercise-info-list slide-lecture-id))  ; info from internal -.exc file
        (exercise-entry (find-in-list   ; finding exercise number on slide in this list. Ugly.
                           (lambda (ee) (and (eq? (as-symbol (first (first ee))) (as-symbol slide-lecture-id))
                                             (eq? (as-symbol (second (first ee))) (as-symbol slide-page-id))
                                             (eq? (as-symbol (third (first ee))) (as-symbol exercise-id-symbol))))  
                           exercise-info-list))
        (front-info-alist (let ((frt-path (front-matter-info-file-name slide-lecture-id)))
                                (if (file-exists? frt-path) (file-read frt-path) '())))
        (exercise-model (defaulted-get 'used-exercise-model front-info-alist 'make-indexes))
       )
    (set! exercise-number (+ 1 exercise-number))
    (set! pending-exercise-hr? #t)
    (let* ((formulation-text (car (element-contents formulation-clause)))
           (lecture-number (lecture-number-of lecture-sections (original-lecture-id theme-id)))
          )
      (let* ((num next-exercise-number)
             (hier-num (if (and lecture-number (number? lecture-number))
                           (con (as-string lecture-number) "." (as-string num))
                           (as-string num))))
        (set! next-exercise-number (+ 1 next-exercise-number)) ; solution only saved in note-style-exercise

        (set! ref-caption-map (cons (make-ref-map-entry attributes lecture-number num) ref-caption-map))

        (presentation-slice
           (a-name (theme-ref-anchor-from-attributes attributes)) 
           (con
            (hr)
            (indent-pixels 
             10
             (con
              (b (con (text-choice "Opgave" "Exercise") " " (as-string hier-num) ". "))  (em title) (p)

              formulation-text

              ; solution info (July, 4 2008). Much harder to dig out than expected. In part, taken from -.exc file. Ugly
              (cond ((and (eq? themes-presentation-medium 'web) exercise-entry solution-clause
			  (memq exercise-model '(make-indexes-and-solutions-per-lecture make-indexes-and-solutions-lecture-wide)))
		     (let ((number-on-slide (fourth (first exercise-entry)))) ; very ugly!
		       (a 'href (exercise-solution-url slide-lecture-id slide-page-id number-on-slide) 
			  (font 'size "2" 'color (rgb-color-encoding grey)  (text-choice "Løsning" "Solution")))))
                    ((and (eq? themes-presentation-medium 'web) exercise-entry solution-clause
			  (not (memq exercise-model '(make-indexes-and-solutions-per-lecture make-indexes-and-solutions-lecture-wide))))
                      (font 'size "2" 'color (rgb-color-encoding grey) (text-choice "Løsningen til denne opgave er pt. ikke frigivet" "The solution to this exercise has not yet been released"))
		    )
                    ((eq? themes-presentation-medium 'web)
                        (font 'size "2" 'color (rgb-color-encoding grey) 
                          (text-choice "Der er ingen løsning til denne opgave" "There is no solution to this exercise")))
                    (else (p)))

              )))
           ""
           (cons (cons 'annotations 'ignore) attributes)
         )
   
      ))))

(define (theme-style-image-series original-contents attributes)  ;   series-title img-subtitle-list how-to-show-list
 (let ((series-title (first original-contents))
       (img-subtitle-list (second original-contents))
       (how-to-show-list (third original-contents))
      )
  (let ((initial-sentence (first-sentence-in-string series-title)))
   (set! image-number (+ 1 image-number))
   (presentation-slice
     (a-name (theme-ref-anchor-from-attributes attributes))
     (con (font-1 note-font-size-left grey1 (b (con initial-sentence (text-choice " (se slide)" " (see slide)")) )) (p))
     ""
     attributes
))))

(define (theme-style-section-title original-contents attributes)
 (let ((title (car original-contents)))
  (set! ref-caption-map (cons (make-ref-map-entry attributes theme-page-number #f) ref-caption-map))
  (presentation-slice
   (a-name (theme-ref-anchor-from-attributes attributes))
   (font-1 6 black (con (as-string (current-theme-number)) "." (horizontal-space 2) title))
   ""
   attributes)))


(define (theme-style-slide-image original-contents attributes)
 (let ((image-file (first original-contents)))
  (presentation-slice
     (a-name (theme-ref-anchor-from-attributes attributes))
     (con (center (img-0 (string-append  "." "/" "graphics/small/" image-file))) (p))
     (con  "" (p))
     attributes
)))

(define (theme-style-applet-program original-contents attributes)  ;   class-file codebase explanation width height
 (let ((class-file (first original-contents))
       (codebase (second original-contents))
       (explanation (third original-contents))
       (width (fourth original-contents))
       (height (fifth original-contents)) 
      )
  (presentation-slice
     (a-name (theme-ref-anchor-from-attributes attributes))
     (con (center (html4:applet "" 'code class-file 'codebase codebase 'height height 'width width)) (p))
     (con  explanation (p))
     attributes
)))


(define (theme-style-synopsis items attributes)
 (let* ((slide-relevant-items (map (lambda (i) (car (element-contents i))) items))
         (explanation-relevant-items  (map extract-synopsis-explanation items))
         (explanation-relevant-items-1 (filter (lambda(e) (not (equal? "" e))) explanation-relevant-items))
         (formatted-slide-relevant-items (map (lambda (e) (font-rise e (+ 1 note-font-size-left))) (map upcase-string slide-relevant-items)))
        )
   (presentation-slice
     (a-name (theme-ref-anchor-from-attributes attributes))
     (con 
       (indent-pixels 10  (center (color-frame (bullet-list formatted-slide-relevant-items 'small 'yellow) synopsis-frame-color)))
       (p)
     )
     (con 
       (string-merge
                explanation-relevant-items-1
                (make-list (length explanation-relevant-items-1) (p)))
       (p))
     attributes
)))

; extract the explanation component "y" of a synopsis item:  (synopsis-item "x" "y")
; in case the list is of lenght 2, return the empty string.
(define (extract-synopsis-explanation i)
 (let ((contents (element-contents i)))
   (if (>= (length contents) 2)
       (cadr contents)
       "")))


(define (theme-style-quotation original-contents attributes)
 (let ((quotation (car original-contents))
       (comment (if (> (length original-contents) 1) (cadr original-contents) ""))
      )
 (presentation-slice
  (a-name (theme-ref-anchor-from-attributes attributes))
  (con (indent-pixels 10 (narrow-with-pixels 50
           (i (string-append (font-rise start-quote note-font-size-left) (note-text-left quotation) (font-rise end-quote note-font-size-left)))))
       (p))
  (con  comment (p))
  attributes 
)))

(define (theme-style-elucidate original-contents attributes)
 (let ((e-title (first-sentence-in-string (first original-contents)))
       (e-full-expl (first original-contents))
       (e-url (second original-contents))
       (e-target (if (>= (length original-contents) 3) (third original-contents) elucidator-default-target))
      )
    (presentation-slice
       (a-name (theme-ref-anchor-from-attributes attributes))
       (table-3 0 (list 100 390) 
                  (list (list (a-tag e-url
                                 (img-LN (elucidator-icon-name language-preference 'small) 
                                         (text-choice "Gå til elucidator" "Go to elucidator")))
                              (font-1 note-font-size-left grey1 (b e-title))))
                  "middle")
       e-full-expl
       attributes
)))

(define (theme-style-elucidator-program-fragment original-contents attributes)
 (let* ((path (first original-contents))
        (elucidator-program-fragment-structure (file-read path))
        (context-url (context-url-of-elucidator-program-fragment elucidator-program-fragment-structure))
        (html-fragment (program-fragment-of-elucidator-program-fragment elucidator-program-fragment-structure))

        (how-to-show (second original-contents))
        (comment (if (>= (length original-contents) 3) (third original-contents) ""))
        (initial-sentence (first-sentence-in-string comment))
       )
  (theme-style-source-program-1 path html-fragment how-to-show comment initial-sentence #f attributes context-url)))

(define (theme-style-lecturer-photos original-contents attributes)
 (let* (
       )
   (presentation-slice 
       (a-name (theme-ref-anchor-from-attributes attributes))
       "Lecturer photos"
       "Comment to lecturer photos"
       attributes)))

(define (theme-style-side-track original-contents attributes)
 (let* ((track-title (first original-contents))
        (track-lecture-id (second original-contents))
        (track-explanation (third original-contents))

        (track-name (side-track-name lecture-id page-id track-lecture-id 'slide))
       )

   (presentation-slice 
       (a-name (theme-ref-anchor-from-attributes attributes))
       (con
         (img-LN "side-track-label.gif" "") (horizontal-space 2)
         (a-tag (theme-url (theme-name-of track-lecture-id)
                           (first-slide-id (theme-name-of track-lecture-id))) ; takes information from theme aux file
                track-title) (br)
         track-explanation)
       ""
       attributes)))

;(define (theme-style-side-track original-contents attributes)
; "")


(define (theme-style-lecturer-photos original-contents attributes)
 "")


; Note about theme treatment splice-page-with and splice-page-without:
; The best thing to do is to unfold these, like we do in lecture-notes-kernel.
; As of now, we ignore them entirely.

(define (theme-style-splice-page-without original-contents attributes)
 "")

(define (theme-style-splice-page-with original-contents attributes)
 "")


; ---------------------------------------------------------------------------------------------------------------

(define (make-top-level-theme-index lecture-list)
 (write-text-file
   (top-level-theme-index lecture-list)
   (destination-path top-level-theme-index-file-name)))


(define (top-level-theme-index lecture-list)
 (let* ((local-lecture-author-info (cons (front-matter-value-of-key 'author) (front-matter-value-of-key 'affiliation)))
        (theme-aux-list-list (map (compose entries-of-aux-file get-theme-aux-structure) lecture-list))
        (lecture-replication-list-list (map2 (lambda (el n) (make-list n el)) lecture-list (map length theme-aux-list-list)))
        (theme-aux-list (flatten theme-aux-list-list))
        (lecture-replication-list (flatten lecture-replication-list-list))

        (shifted-lecture-replication-list 
          (if (null? lecture-replication-list)
              '()
              (cons #f (list-prefix lecture-replication-list (- (length lecture-replication-list) 1)))))

        (possible-em  ; emphasize ttl if id is not the same as id-prev
          (lambda (ttl id id-prev) 
            (if (or (not id-prev) (not (equal? id id-prev)))
                (b ttl)
                ttl)))
        (start-of-new-lecture? 
          (lambda (id id-prev)
            (or (not id-prev) (not (equal? id id-prev)))))
        (present-aux-entry
          (lambda (aux-e lecture-id prev-lecture-id n)
           (let ((n-str (con (as-string n) "."))
                 (sp (horizontal-space 5))
                 (ttl (title-of-aux-entry aux-e))
                )
            (if (start-of-new-lecture? lecture-id prev-lecture-id)
                (list     ; list in list - flatten afterwards
                  (list
                   (a-tag (string-append (as-string lecture-id) ".html") (img-LN "box.gif" "Slides in this lecture")) ; (b "***")
                   (b (upcase-string (lecture-title-given-lecture-id lecture-id))))
                  (list (if (and (eq? themes-presentation-medium 'paper) (or (not prev-lecture-id) (not (equal? lecture-id prev-lecture-id)))) ; paper and lecture start
                            (a 'href (html-file (aggregated-themes-name lecture-id)) n-str) 
                            n-str )
                        (a 'href (html-file (theme-name (theme-name-of lecture-id) (id-of-aux-entry aux-e)))
                           'title (lecture-title-given-lecture-id lecture-id)
                           ttl)))
                (list     ; list in list - flatten afterwards
                  (list (if (and (eq? themes-presentation-medium 'paper) (or (not prev-lecture-id) (not (equal? lecture-id prev-lecture-id)))) ; paper and lecture start
                          (a 'href (html-file (aggregated-themes-name lecture-id)) n-str) 
                          n-str )
                      (a 'href (html-file (theme-name (theme-name-of lecture-id) (id-of-aux-entry aux-e)))
                         'title (lecture-title-given-lecture-id lecture-id)
                         ttl))))
            )))
        (lst-lgt (length theme-aux-list))
       )
  (page-with-keypress-script
   notes-title
   '()
    (con 

      (theme-front-index-header)

      ; title and subtitle
      (font-size 6 (b notes-title)) (br) 
      (if notes-subtitle (font-size 5 (b notes-subtitle)) "")

      ; author name and affiliation
      (h 3
         (con 
          (list-to-string 
           (map (lambda (e) (con e (br))) (append local-lecture-author-info (list lecture-date)))
           ""
           )
          )
      )

      ; news flash
      (if (>= news-flash-level 1) (indent-pixels 20 (leno-news-flash 3 (- preferred-theme-page-width 40))) "")

      (if top-level-title-page?
	  (a-tag
	   (html-file (top-level-title-page-name))
	   (font-size 2 (text-choice "Forside" "Title page"))
	   )
	  "")

      (horizontal-space 12)

      (if top-level-abstract-page?
	  (a-tag
	   (html-file (top-level-abstract-page-name))
	   (font-size 2 (text-choice "Sammendrag" "Abstract"))
	   )
	  "")

      (horizontal-space 12)


      (if (not (null? (lecture-wide-exercise-list)))
          (con 
           (a-tag (html-file overall-exercise-index-name) 
                  (font-size 2 (text-choice "Alle opgaver i dette materiale" "All exercises in this material")))
           (horizontal-space 8)
           )
          "")

      (if cross-references?
          (a-tag (html-file global-cross-reference-name)
                 (font-size 2 (text-choice "Alle referencer fra dette materiale" "All references in this material")))
          "")

      ; abstract
      (if (and (not top-level-abstract-page?) (not (equal? note-abstract "")))
          (con (indent-pixels 20 (color-frame-width (em note-abstract) grey2 (- preferred-theme-page-width 40))) (p))
          "")

      (vertical-space 1)

      ; index proper
      (indent-pixels 10

       (let ((entries
              (append 
               (cond ((eq? themes-presentation-medium 'paper)
                      (list (list "" (a 'href (html-file (theme-front-matters-name)) (b (text-choice "Titelark" "Front matters"))))))
                     ((eq? themes-presentation-medium 'web)
                      '())
                     (else (laml-error "Linking to front matters. themes-presentation-medium must be web or paper" 
                                       themes-presentation-medium)))
               (flatten (map4 present-aux-entry
                     theme-aux-list lecture-replication-list shifted-lecture-replication-list (number-interval 1 lst-lgt)))
               )))
        
       (if (< (length entries) one-column-limit-top-level-index)
           (table-3 0
             (list 25 "*")
             entries
           )
           (let* ((sublisted-entries (sublist-by-2columns entries '("" "")))
                  (appended-sublisted-entries (map (lambda (two-list-entry) (apply append two-list-entry)) sublisted-entries)))

; Layout before January 29, 2008:
;            (table-3 0
;              (list 25 (as-string two-column-top-level-index-width) 25 (as-string two-column-top-level-index-width))
;              appended-sublisted-entries)

            (table-3 0
              (list (+ 25 two-column-top-level-index-width) (+ 25 two-column-top-level-index-width))
              (list 
               (list
                (table-3 0 (list 25 "*") (front-sublist entries (quotient (length entries) 2)))
                (table-3 0 (list 25 "*") (rear-sublist  entries (- (length entries) (quotient (length entries) 2)))))
              )
            )
          )
       )
 

       ))

      (p)


      (left-middle-right-banner
       (leno-icon)
       (when-generated)
       (laml-power-icon "")
       )

;      (table-3 0 (list 180 "*") 
;                  (list (list  (laml-power-icon "") (when-generated))))


   )
   javascript-loading
   (list (string-append leno-software-directory "javascript/") "lenonavigate.js")
   (js-call "lenoNavigate" 
                 (append
                  (map string-it-single 
                       (list ""
                             ""
                             "" 
                             ""
                             "" "" (html-file top-level-note-file-name)
                  ))
                  (list ) ))

   white black black black
   'double-press
   (actual-stylesheets apply-css-styling?)
   (leno-css-class 'index)
   )))

(define (theme-front-index-header)
 (header-banner
  (con
   (img-LN "nav-up-empty.gif" "") (space 2)

     (a-tag course-home-url (img-LN "nav-home.gif" (text-choice "Kurset's hjemmeside" "Course home"))) (space 2)

; Commented out June 10, 2002.
; Reason: note-download-url not defined when using xml-in-laml.
; Solution: include them in leno-themes-front-matters.

   (if (not (equal? note-download-url ""))
       (a-tag note-download-url (img-LN "todisk.gif" (text-choice "Download noter" "Download notes (zip file)")))
       (space 3))   (space 2)

   (if word-index? 
       (a-tag (all-word-index-url lecture-id) (img-LN "index.gif" (text-choice "Alfabetisk indeks" "Alphabetic index")))
       (space 3))

     (space 2)
; 
;    (if exercise-index? 
;        (con (a-tag (html-file overall-exercise-index-name) (img-LN "think.gif" (text-choice "Opgave oversigt" "Exercise index"))) (space 2))
;        (space 3))
   
   (no-frames-button (html-file top-level-theme-file-name)) (space 3)

   (con (a-tag (html-file top-level-note-file-name)
               (img-LN "letter-l.gif" (text-choice "Oversigt over lektionssider" "Lecture note overview")))
        (space 3))

   (if make-print-page?
       (con 
         (a-tag (html-file (print-page-name))
                   (img-LN "print-icon.gif" (text-choice "PDF print side" "PDF print page")))
         (space 3))
       (space 2))

 )

 (a-tag about-laml-url (img-LN "question.gif" (text-choice "Hjælp om disse noter" "Help page about these notes")))
 )
)

; Return an aux structure. If no aux file exists, return
; a dummy structure ("???")
(define (get-theme-aux-structure lecture-id)
 (let ((theme-aux-file (aux-file-name (theme-name-of lecture-id))))
  (if (file-exists? theme-aux-file)
      (file-read theme-aux-file)
      (list "???"))))

; Return the start section number of theme-id relative to lecture-list
; Calculate it from the aux file, by counting and measuring lengths
(define (start-section-of-lecture theme-id lecture-list)
 (let ((lid (as-string (original-lecture-id theme-id))))
   (cond ((null? lecture-list) (laml-error "start-section-of-lecture: Cannot locate theme-id in prefix of lecture-list"))
         ((equal? lid (car lecture-list)) 0)
         (else (+ (length (entries-of-aux-file (get-theme-aux-structure (car lecture-list))))
                  (start-section-of-lecture theme-id (cdr lecture-list)))))))


; missing the themes-id identification

; Return a (themes-id  theme-id) pair of the previous page, globally in all themes, and
; relative to theme-page-number
(define (previous-global-themes-page)
 ; uses the global variable theme-page-number and the value of (global-themes-page-list) to return the name of the previous page.
 ; returns #f in case we are located at the first page.
 (let ((old-length (length (global-themes-page-list))))
  (cond ((or (< theme-page-number 1) (> theme-page-number old-length)) #f) 
        ((= 1 theme-page-number) #f)
        (else (list-ref (global-themes-page-list) (- theme-page-number 2))))))

; Return a (themes-id  theme-id) pair of the next page, globally in all themes, and
; relative to theme-page-number
(define (next-global-themes-page)
 ; uses the global variable theme-page-number and the value of (global-themes-page-list) to return the name of the next page.
 ; returns #f in case we are located at the last page.
 (let ((old-length (length (global-themes-page-list))))
  (cond ((or (< theme-page-number 1) (> theme-page-number old-length)) #f)
        ((= old-length theme-page-number) #f)
        (else (list-ref (global-themes-page-list) theme-page-number)))))


; for caching in global-themes-page-list
(define remembered-global-themes-page-list '())

; Return the list of all lists (themes-id  theme-id) of all themes in the material.
; Takes it from the aux file
(define (global-themes-page-list)
  (let ((themes-list (map theme-name-of lecture-list)))

                                        ; note page ids from previous run
                                        ; Please notice the caching in remembered-global-themes-page-list
    (cond ((not (null? remembered-global-themes-page-list)) remembered-global-themes-page-list)
          ((aux-files-exist? themes-list) 
           (let* ((gtpl-list 
                   (map 
                    (lambda (id) (prepare-aux-1 (file-read (aux-file-name id)) id))
                    themes-list))
                  (gtpl (flatten gtpl-list))
                 )
             (set! remembered-global-themes-page-list gtpl)
             gtpl))
          ((some-aux-files-exist? themes-list)   ; probably just else clause
           (let* ((gtpl-list 
                   (map 
                    (lambda (id) (prepare-aux-1 (if (file-exists? (aux-file-name id)) (file-read (aux-file-name id)) '()) id))
                    themes-list))
                  (gtpl (flatten gtpl-list))
                 )
             (set! remembered-global-themes-page-list gtpl)
             gtpl))
          (else '()))))

(define (prepare-aux-1 lst id)
  ; return the note-page-list, i.e. a list of slide-id symbols
  ; lst starts with lecture-title and then has a strings of (title slide-id section-boolean) tripples
  (map (lambda (x) (list id x)) 
    (map id-of-aux-entry (entries-of-aux-file lst))))

(define (aux-files-exist? lecture-list)
  (accumulate-right (lambda (x y) (and x y)) #t (map (compose file-exists? aux-file-name) lecture-list)))

; Can be improved:
(define (some-aux-files-exist? lecture-list)
  #t)

; ------------------------------------------------------------------------------------------------------
; Theme style cross reference section:
  
(define (theme-reference-part theme-cross-reference-list)
 (let ((glue-ref-and-hint (lambda (refs) (map (lambda (url-hint-pair) (string-append (second url-hint-pair) (third url-hint-pair))) refs))))
  (set! theme-sub-number (+ 1 theme-sub-number))
  (let* ((formatter-function theme-style-cross-reference-formatter)
         (filtered-refs     ; no note references, no internet references without id
           (filter 
            (lambda (cross-ref-el) 
             (not (or (eq? 'note-reference (cross-ref-type cross-ref-el))
                      (and (eq? 'internet-reference (cross-ref-type cross-ref-el)) 
                           (not (defaulted-get 'id (cross-ref-attributes cross-ref-el) #f)) ))))
             theme-cross-reference-list))
         (unique-refs (remove-duplicates-by-predicate filtered-refs ref-equal?))
         (sorted-refs                                     ; Nov 22, 2002: Can apparently not sort empty list with sort-list with PLT 103 on a PC!!!
           (if (null? unique-refs) '() (sort-list unique-refs cross-ref-leq?)))
         (formatted-refs (map formatter-function sorted-refs))
         (hint-glued-formatted-refs (glue-ref-and-hint formatted-refs))
         (keys (map first formatted-refs))
        )
    (if (> (length formatted-refs) 0)
        (con
         (if pending-exercise-hr?  ; end of exercises - make trailing hr
             (begin
               (set! pending-exercise-hr? #f)
               (hr))
             "")
         (vertical-space 1)
         (theme-title-line (current-theme-sub-number) (text-choice "Referencer" "References")) (br)
         (presentation-slice
          "" 
          (table-3 0
           (list "130" "*")
           (map2 
             (lambda (key ref-text) 
               (list (con "[" (if key (con (a-name (ref-anchor-name key)) (capitalize-string (as-string key))) "-") "]")
                     ref-text))
             keys hint-glued-formatted-refs
             ))
          
          ""
          '())
         )
        "")
    )))



(define (cross-ref-leq? e1 e2)
  (let ((e1-key (element-id e1))
        (e2-key (element-id e2))
       )
   (cond ((and e1-key e2-key) (string<=? (as-string e1-key) (as-string e2-key)))
         ((and e1-key (not e2-key)) #t)
         ((and (not e1-key) e2-key) #f)
         (else (string<=? (as-string (cross-ref-title e1) (cross-ref-title e2)))))))


(define (ref-equal? e1 e2)
  (if (eq? (cross-ref-type e1) (cross-ref-type e2))
      ((gen-ref-equal-homogenous (cross-ref-type e1)) e1 e2)
      #f))

; return an equality function on pairs of references of the same type
(define (gen-ref-equal-homogenous ref-type)
 (cond ((eq? ref-type 'note-reference) 
          (lambda (e1 e2) (and (eq? (cross-ref-lecture-id e1) (cross-ref-lecture-id e2))
                               (eq? (cross-ref-page-id e1) (cross-ref-page-id e2)))))
       ((eq? ref-type 'internet-reference) 
          (lambda (e1 e2) (equal? (cross-ref-url e1) (cross-ref-url e2))))
       ((eq? ref-type 'informal-reference) 
          (lambda (e1 e2) (equal? (cross-ref-title e1) (cross-ref-title e2))))
       ((eq? ref-type 'bibtex-reference) 
          (lambda (e1 e2) (eq? (cross-ref-key e1) (cross-ref-key e2))))
       (else (laml-error "gen-ref-equal-homognous: unknown reference type: " ref-type))))

; Compare two cross reference (sub)clauses
(define (cross-ref-leq? e1 e2)
  #t)

; Return a list of (1) id (of #f if no id is present), (2) cross reference text and (3) location hint
(define (theme-style-cross-reference-formatter cross-ref-record)
 (let ((descr (cross-ref-title cross-ref-record))
       (type (cross-ref-type cross-ref-record))
       (loc-hint (cross-reference-location-hints (cross-ref-location-hints cross-ref-record)))
      )
  (cons (element-id cross-ref-record)
        (cond ((eq? type 'internet-reference)
               (let ((url (cross-ref-url cross-ref-record)))
                 (list (con (a-tag url descr) (br) (font-size 2 url)) loc-hint)))
              ((eq? type 'note-reference)
               (let ((lect-id (cross-ref-lecture-id cross-ref-record))
                     (page-id (cross-ref-page-id cross-ref-record))
                     )
                 (list (a-tag (url-function lect-id page-id) descr) loc-hint)))
              ((eq? type 'informal-reference)
               (let ((informal-ref (cross-ref-reference cross-ref-record)))
                 (list (string-append descr ": " informal-ref) loc-hint)))
              ((eq? type 'bibtex-reference)
               (let* ((bibtex-entry (locate-bibtex-entry (cross-ref-key cross-ref-record)))
                      (url (if bibtex-entry (bibtex-return-url bibtex-entry) #f))
                      )
;                (if url 
;                     (list (a-tag url descr) loc-hint)
;                    (list descr loc-hint))
                 (list (present-bibtex-entry bibtex-entry) loc-hint)
              ))
              (else (error "Problems in format-cross-ref. Second item is unknown"))))))

; Return a reference anchor name
(define (ref-anchor-name key)
  (string-append "ref-" (downcase-string (as-string key))))

; Return a cite clause, applicable in theme-text, for creation of a 
; link to a reference in the reference list, at the bottom of the page.
; Key is an id of LENO cross reference entry.
; If a LENO bibtex is used, and no id is supplied, the id automatically becomes the key. 
; (Done in: styles/xml-in-laml/lecture-notes/lecture-notes-transition.scm).
(define (cite key)
  (a-tag (string-append "#" (ref-anchor-name key))
         (string-append "[" (as-string key) "]")))

; Similar to (cite key), but this version is used in cases where
; the bibtex entry is not part of a LENO cross-references clause. Thus,
; we use (bib-cite ...) when we want to add a bibtex citation from a thematic page.
; Use of bib-cite will add a  bibtex entry to theme-cross-reference-list.
(define (bib-cite . keys)
 (let ((faked-bibtex-entry
         (lambda (key)
           (list 'bibtex-reference 
                 (as-symbol (downcase-string key))
                 (list key '())
                 (list (cons 'key key))))))
  (for-each 
    (lambda (key)
      (set! theme-cross-reference-list 
            (cons (faked-bibtex-entry key) theme-cross-reference-list)))
    keys)

  (con
    "["
     (list-to-string 
       (map (lambda (key)
           (a-tag (string-append "#" (ref-anchor-name key))
                  (as-string key) ))
         keys) ", ")
    "]")))

(define (bib-cite-1 key)
 (let ((faked-bibtex-entry
         (lambda (key)
           (list 'bibtex-reference 
                 (as-symbol (downcase-string key))
                 (list key '())
                 (list (cons 'key key))))))
  (set! theme-cross-reference-list 
        (cons (faked-bibtex-entry key) theme-cross-reference-list))

  (a-tag (string-append "#" (ref-anchor-name key))
         (string-append "[" (as-string key) "]"))))

; Return a reference to an element on a theme page
; The optional parameter is an anchor text, to be used in case we cannot locate a 
; page number contribution in the -_themes.ref file. 
(define (ref theme-page-name lecture-id page-id element-type element-id-or-number . optional-parameter-list)
 (let* ((page-number-list (page-number-lookup lecture-id page-id element-type element-id-or-number))
        (kind (kind-lookup lecture-id page-id element-type element-id-or-number))
        (anchor-text 
          (if page-number-list 
              (number-subnumber-presentation (as-symbol element-type) kind page-number-list)
              (optional-parameter 1 optional-parameter-list "???")))
       )

  (if (and (>= lecture-note-verbose-mode 1) (not page-number-list))
      (display-warning "Cannot locate the reference:" lecture-id page-id element-type element-id-or-number))

  (con 
    (if spacy-references? " " "") 
    (a-tag 
     (string-append (html-file (as-string theme-page-name)) "#" (theme-ref-anchor lecture-id page-id element-type element-id-or-number))
     anchor-text)
    (if spacy-references? " " "") )))

; A wrapper around (ref ...) used to signify a web only reference
(define (web-only-ref ref-clause)
  (if  (eq? themes-presentation-medium 'web)
       (con ref-clause " " "(only on web)")
       (con ref-clause " " "(only on web)")))

; Only show leno-element-clause in web editions.
; Increment the program number even in the paper edition.
(define (web-only-program leno-element-clause)
  (if (eq? themes-presentation-medium 'web)
      leno-element-clause
      (begin
        '())))

; kind only applied for source programs, and it reflects a variation. Currently we support kind listing.
(define (number-subnumber-presentation element-type kind page-number-list)
  (let* ((n1 (first page-number-list))
         (n2 (second page-number-list))
         (number-contribution 
           (if n2
               (string-append (as-string n1) "." (as-string n2))
               (as-string n1)))
        )
   (cond ((and (eq? element-type 'source-program) (eq? kind 'listing)) (string-append (text-choice "listning" "Listing") " " number-contribution))
         ((eq? element-type 'source-program) (string-append (text-choice "program" "Program") " " number-contribution))
         ((eq? element-type 'language-syntax) (string-append (text-choice "syntaks" "Syntax") " " number-contribution))
         ((eq? element-type 'image) (string-append (text-choice "figur" "Figure") " " number-contribution))
         ((eq? element-type 'svg-image) (string-append (text-choice "figur" "Figure") " " number-contribution))
         ((eq? element-type 'tabular) (string-append (text-choice "tabel" "Table") " " number-contribution))
         ((eq? element-type 'concept-list) (string-append (text-choice "begreb" "Concept") " " number-contribution))
         ((eq? element-type 'exercise) (string-append (text-choice "opgave" "Exercise") " " number-contribution))
         ((eq? element-type 'title) (string-append (text-choice "afsnit" "Section") " " number-contribution))
         ((eq? element-type 'section-title) (string-append (text-choice "kapitel" "Chapter") " " number-contribution))
         ((eq? element-type 'side-box) (string-append (text-choice "Fokus boks" "Focus box") " " number-contribution))
         (else (string-append "???" " " number-contribution)))))

; Return a pretty printed (ref ...) clause, which can be rendered
; as a help to a LENO theme author (if author-theme-rendering).
; Relies on the global variable current-theme-page-name.
; (define (pp-ref attr-list)
;  (let ((lec-id (defaulted-get 'lecture-id attr-list #f))
;        (pg-id (defaulted-get 'page-id attr-list #f))
;        (el-ty (defaulted-get 'element-type attr-list #f))
;        (el-id (defaulted-get 'element-id attr-list #f))
;        (el-nu (defaulted-get 'element-number attr-list #f))
;        (SP " ")
;       )
;   (if (and author-theme-rendering lec-id pg-id el-ty (or el-id el-nu)) 
;       (con 
;        (font-size 
;       1 
;       (b
;        (string-append
;         "(" "ref" SP
;         (string-it current-theme-page-name) SP (string-it lec-id) SP (string-it pg-id) SP
;           (string-it el-ty) SP (string-it (if el-id el-id el-nu))
;         ")"))) 
;        (br))
;       "")))

(define (pp-ref attr-list)
 (let ((lec-id (defaulted-get 'lecture-id attr-list #f))
       (pg-id (defaulted-get 'page-id attr-list #f))
       (el-ty (defaulted-get 'element-type attr-list #f))
       (el-id (defaulted-get 'element-id attr-list #f))
       (el-nu (defaulted-get 'element-number attr-list #f))
       (SP " ")
      )
  (if themes-author-mode
   (a 'href
      (string-append
       (html-file (author-ref-help-name theme-id)) "#"
       (author-ref-help-anchor-name lec-id pg-id el-ty el-id el-nu))
      'css:text-decoration "none"
      'title (as-string el-ty)
      (font-color red "*"))
   "")))

; Same as above, but with explicite parameters.
(define (pp-ref-pars lec-id pg-id el-ty el-id el-nu)
  (if themes-author-mode
   (a 'href
      (string-append
       (html-file (author-ref-help-name theme-id)) "#"
       (author-ref-help-anchor-name lec-id pg-id el-ty el-id el-nu))
      'css:text-decoration "none"
      'title (as-string el-ty)
      (font-color red "*"))
   ""))


; ---------------------------------------------------------------------------------------------------
; Functions that return hierarchical figure numbers, program numbers, etc.

(define (current-program-number)
  (string-append (as-string theme-page-number) "." (as-string program-sub-number)))

(define (current-figure-number)
  (string-append (as-string theme-page-number) "." (as-string figure-sub-number)))

(define (current-syntax-number)
  (string-append (as-string theme-page-number) "." (as-string syntax-sub-number)))

(define (current-table-number)
  (string-append (as-string theme-page-number) "." (as-string table-sub-number)))

(define (current-concepts-number)
  (string-append (as-string theme-page-number) "." (as-string concepts-sub-number)))

(define (current-side-box-number)
  (string-append (as-string theme-page-number) "." (as-string side-box-sub-number)))

; -----------------------------------------------------------------------------
; -.ref file support 
; Ref files map (theme-page-name lecture-id page-id element-type element-id-or-number) to
; (element-kind section-number sub-number)
; ref files only contain contributions for elements presented with captions.
; There are currently no accessors to this structure. Access takes place in the functions page-number-lookup and kind-lookup.

; Return the full path of an ref file for id (hnderstood as theme-id)
; Id defaults to the value of the global varible lecture-id
(define (ref-file-name . optional-parameter-list)
 (let ((id (as-string (optional-parameter 1 optional-parameter-list theme-id))))
   (string-append note-source-directory "internal/" id ".ref")))

(define (make-ref-map-entry attr-list number sub-number)
 (let ((lec-id (get 'lecture-id attr-list))
       (pg-id (get 'page-id attr-list))
       (el-ty (get 'element-type attr-list))
       (el-id (defaulted-get 'element-id attr-list #f))
       (el-nu (defaulted-get 'element-number attr-list #f))
       (el-kind (defaulted-get 'kind attr-list #f))  ; only used for source programs: source-program or listing
      )
   (list (as-symbol lec-id) (as-symbol pg-id) (as-symbol el-ty) (if el-id (as-symbol el-id) (as-number el-nu)) (if el-kind (as-symbol el-kind) #f) number sub-number)))

  
(define (all-ref-entries)
 (let ((lecture-theme-list (map theme-name-of lecture-list))
       (file-read-empty-if-none (lambda (f) (if (file-exists? f) (file-read f) '()))))
  ; collect all cross references from -.crs files
    (accumulate-right append '()
              (map file-read-empty-if-none
                   (map (lambda (f) (ref-file-name f))  
                        lecture-theme-list)))))

; Return a list of page-numer and sub-number by looking up in the ref map list in the total, accumulated -.ref files.
; Return #f if not found
(define (page-number-lookup lecture-id page-id element-type element-id-or-number)
 (let ((res (find-in-list 
             (lambda (ref-entry)
               (and
                (eq? (first ref-entry) (as-symbol lecture-id))
                (eq? (second ref-entry) (as-symbol page-id))
                (eq? (third ref-entry) (as-symbol element-type))
                (if (symbol? (fourth ref-entry))
                    (eq? (fourth ref-entry) (as-symbol element-id-or-number))
                    (eq? (fourth ref-entry) (as-number element-id-or-number)))))
             old-total-ref-caption-map)))
   (if res
       (list (sixth res) (seventh res))
       #f)))

; Return the kind given by lecture-id page-id element-type element-id-or-number. 
; Only applied for source programs: either source-program or listing.
(define (kind-lookup lecture-id page-id element-type element-id-or-number)
 (let ((res (find-in-list 
             (lambda (ref-entry)
               (and
                (eq? (first ref-entry) (as-symbol lecture-id))
                (eq? (second ref-entry) (as-symbol page-id))
                (eq? (third ref-entry) (as-symbol element-type))
                (if (symbol? (fourth ref-entry))
                    (eq? (fourth ref-entry) (as-symbol element-id-or-number))
                    (eq? (fourth ref-entry) (as-number element-id-or-number)))))
             old-total-ref-caption-map)))
   (if res
       (fifth res)
       #f))) 
    

; Return the id of the theme page in a lecture.
; Return the empty string if it cannot be located.
(define (first-theme-id lecture-id)
  ; find first slide id from aux file
  (let ((aux-file (aux-file-name lecture-id)))
    (if (file-exists? aux-file)
        (let ((entries (entries-of-aux-file (file-read aux-file))))
          (if (null? entries) "" (id-of-aux-entry (first entries))))
        "")))



; ---------------------------------------------------------------------------------------------------
; Author ref help

(define (make-ref-entry current-theme-page-name lect-id page-id el-type element-id element-number)
  (list 'ref-entry current-theme-page-name lect-id page-id el-type element-id element-number))

(define theme-page-name-of-ref-entry (make-selector-function 2))
(define lecture-id-of-ref-entry (make-selector-function 3))
(define page-id-of-ref-entry (make-selector-function 4))
(define element-type-of-ref-entry (make-selector-function 5))
(define element-id-of-ref-entry (make-selector-function 6))
(define element-number-of-ref-entry (make-selector-function 7))

(define (author-ref-help-name themes-id)
  (string-append (as-string themes-id) "-" "author-ref-help"))


(define (author-ref-help ref-info-list)
  (con

    (h 1 "Author ref help")

    (ul-1
      (map present-author-ref-help-entry ref-info-list))

    (vertical-space 30)

  ))


(define (present-author-ref-help-entry entry)
  (con 
    (a-name (author-ref-help-anchor-name (lecture-id-of-ref-entry entry) (page-id-of-ref-entry entry) (element-type-of-ref-entry entry)
                                    (element-id-of-ref-entry entry) (element-number-of-ref-entry entry)  ))
    "(ref "
    (string-it (as-string (theme-page-name-of-ref-entry entry))) " "
    (string-it (as-string (lecture-id-of-ref-entry entry))) " " 
    (string-it (as-string (page-id-of-ref-entry entry))) " " 
    (string-it (as-string (element-type-of-ref-entry entry))) " "
    (if (element-id-of-ref-entry entry)
        (string-it (as-string (element-id-of-ref-entry entry)))
        (con (string-it (as-string (element-number-of-ref-entry entry)))))
    ")"

    (br)
    (font 'size "1" 
      (html-file (as-string (theme-page-name-of-ref-entry entry))) _ "#" _
          (theme-ref-anchor (lecture-id-of-ref-entry entry) (page-id-of-ref-entry entry) (element-type-of-ref-entry entry)
                            (if (element-id-of-ref-entry entry) (element-id-of-ref-entry entry) (element-number-of-ref-entry entry))))))


; The anchor name of a help entry
(define (author-ref-help-anchor-name lid pid type el-id num)
  (string-append
    (as-string lid) "-" 
    (as-string pid) "-" 
    (as-string type) "-"
    (if el-id
        (as-string el-id)
        (as-string num))))
    

; Return a string such as "Lecture 3 - page 4" from lecture-id and page-id.
; Access the information in the internal leno aux - not the leno theme aux file.
(define (lecture-and-page-information lecture-id page-id)
 (let* ((aux-entry (find-original-slide-info lecture-id page-id)) ; lecture-notes-kernel function
        (page-number (page-number-of-aux-entry aux-entry))
       )
  (string-append (text-choice "Lektion" "Lecture") " " (as-string (lecture-number-of lecture-sections lecture-id)) " - "
                 (text-choice "slide" "slide") " " (as-string page-number)))) 



; ---------------------------------------------------------------------------------------------------------------

; Return the theme front matters page.
; This page is linked together with the thematic overview.
; We deal with theme front matters stuff at kernel level, because we do have 
; appropriate information about author and affiliation at theme level.
(define (theme-front-matters)
 (let* ((local-lecture-author-info (cons (front-matter-value-of-key 'author) (front-matter-value-of-key 'affiliation)))
        (theme-aux-list (flatten (map (compose entries-of-aux-file get-theme-aux-structure) lecture-list)))
        (section-title-list (map title-of-aux-entry theme-aux-list))

        (the-body 
         (center
          (con
           (vertical-space 2)
           (font-1 7 black (con (front-matter-value-of-key 'notes-title)))
           (if notes-subtitle (con (br) (font-1 6 black (front-matter-value-of-key 'notes-subtitle))) "")
           (vertical-space 2)
           (font-1 5 black (em (car local-lecture-author-info))) (br) ; author
           (font-1 5 black
                   (apply con
                          (map (lambda (e) (con e (br))) (cdr local-lecture-author-info)))
                   )
           (font-1 4 black lecture-date)

           (vertical-space 2)

           (center (h2 (text-choice "Sammendrag" "Abstract"))) (br)
           (narrow-with-pixels 70 (font-size 2 (front-matter-value-of-key 'note-abstract)))

           (vertical-space 2)

           (narrow-with-pixels 100 (font-size 1 (leno-theme-material-colophon)))

           (vertical-space 2)

           (center (h2 (text-choice "Indhold" "Contents")))

           (if (eq? themes-presentation-medium 'paper)
               (table-1 0
                        (list 30 600 100)
                        (list white white white)
                        (map 
                         (lambda (n ttl) 
                            (list (b (string-append (if (<= n 9) (string-append (horizontal-space 1) (as-string n)) (as-string n)) "."))
                                   ttl
                                   "nnn"
                                  ))
                         (number-interval 1 (length section-title-list))
                         section-title-list)
               )
               (table-1 0
                        (list 30 700)
                        (list white white)
                        (map 
                         (lambda (n ttl) 
                            (list (b (string-append (if (<= n 9) (string-append (horizontal-space 1) (as-string n)) (as-string n)) "."))
                                   ttl))
                         (number-interval 1 (length section-title-list))
                         section-title-list)
               )
           )
      
           )
          )))
    (let ((body-attributes (list 
                               'bgcolor (rgb-color-encoding theme-background-color)
                               'text (rgb-color-encoding black)
                               'link (rgb-color-encoding black)
                               'vlink (rgb-color-encoding black)))
          (underline-suppress (style 'type "text/css" "A {text-decoration: \"none\";}"))
         )
         (html
          (head (title notes-title) (if (eq? themes-presentation-medium 'paper) underline-suppress ""))
          (body the-body body-attributes)))))


; You may redefine the function in the Scheme suffix file to make it more specific
(define (leno-theme-material-colophon)
   (p (b "Colophon: ") "This material has been authored using the LENO language. LENO is an XML language, which
       at the grammatical level is defined using an XML DTD. We use LENO in the context of LAML,
       which allows us to author LENO material in the Scheme programming language. Thus, all source
       material is written in Scheme, using the mirrors of the XML LENO language, and a mirror of HTML.
       The primary LENO language is
       used to produced annotated slide pages, in a number of different views."))



; ---------------------------------------------------------------------------------------------------------------

; Access to the front matter info file association list - the content of the internal -.frt file

(define remembered-front-matter-info-list '()) 

; Return the frt structure from the internal frt file.
; Accepts an optional lecture-id parameter, which must be the lecture id of the primary source.
(define (get-front-matter-info-list . optional-parameter-list)
 (let ((id  (as-string (optional-parameter 1 optional-parameter-list (original-lecture-id lecture-id)))))

  (cond ((not (null? remembered-front-matter-info-list)) remembered-front-matter-info-list)
        ((file-exists? (front-matter-info-file-name id)) 
           (let* ((front-matter-structure (file-read (front-matter-info-file-name id))))
             (set! remembered-front-matter-info-list front-matter-structure)
             front-matter-structure))
        (else '()))))


; Return the value of key in the front matter info association list.
; An optional lecture-id can be give - defaults to lecture-id of the primary source.
; If no value is found, stop with a fatal error (via the error cause by getting a non-existing value via get).
(define (front-matter-value-of-key key . optional-parameter-list)
 (let* ((id (as-string (optional-parameter 1 optional-parameter-list (original-lecture-id lecture-id))))
        (alist (get-front-matter-info-list id))
       )
   (get key alist)))

  
; ---------------------------------------------------------------------------------------------------------------


; Constructor and selectors of aux1 theme entries.
; An aux1 entry describes a chapter or a section by means of title and ids.
; Supports fine grained previous/next navigationin between chapter/sections.
; In comparison, and aux theme entry only describe the chapters.

(define (make-aux1-entry kind title lecture-id section-id page-id chapter-number section-number)
 (list 'aux1-entry kind title lecture-id section-id page-id  chapter-number section-number))

(define kind-of-aux1-entry (make-selector-function 2 "kind-of-aux1-entry"))
(define title-of-aux1-entry (make-selector-function 3 "title-of-aux1-entry"))
(define lecture-id-of-aux1-entry (make-selector-function 4 "lecture-id-of-aux1-entry"))
(define section-id-of-aux1-entry (make-selector-function 5 "section-id-of-aux1-entry"))
(define page-id-of-aux1-entry (make-selector-function 6 "page-id-of-aux1-entry"))
(define chapter-number-of-aux1-entry (make-selector-function 7 "chapter-number-of-aux1-entry"))
(define section-number-of-aux1-entry (make-selector-function 8 "section-number-of-aux1-entry"))

(define (aux1-file-name id)
   (string-append note-source-directory "internal/" (as-string id) ".aux1"))

(define (read-aux1-file-if-exists lecture-id)
  (let ((path (aux1-file-name lecture-id)))
    (if (file-exists? path)
        (cdr (file-read path))   ; skip first entry: title of material  
       '())))

; Search for 'element before' in total-aux1-list relative to the parameters
(define (find-previous-chapter-section-page-id kind lecture-id page-id)
  (element-before (list kind (as-string lecture-id) (as-string page-id))
                  total-aux1-list
                  (lambda (aux1-entry) (list (kind-of-aux1-entry aux1-entry) (lecture-id-of-aux1-entry aux1-entry) (page-id-of-aux1-entry aux1-entry)))
                  equal?))

; Search for 'element after' in total-aux1-list relative to the parameters
(define (find-next-chapter-section-page-id kind lecture-id page-id)
  (element-after (list kind (as-string lecture-id) (as-string page-id))
                  total-aux1-list
                  (lambda (aux1-entry) (list (kind-of-aux1-entry aux1-entry) (lecture-id-of-aux1-entry aux1-entry) (page-id-of-aux1-entry aux1-entry)))
                  equal?))

(define (aux1-anchor aux1-entry)
 (cond ((eq? 'title (kind-of-aux1-entry aux1-entry))
           (string-append (theme-ref-anchor (lecture-id-of-aux1-entry aux1-entry) (page-id-of-aux1-entry aux1-entry) "title" 1)))
       ((eq? 'section-title (kind-of-aux1-entry aux1-entry))
           "theme_top")
       (else (laml-error "aux1-anchor: Can only make anchor text for title and section-title entries:" (kind-of-aux1-entry aux1-entry)))))

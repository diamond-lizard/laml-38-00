; This file is generated by an LAML script based on the LAML tool tools/xml-in-laml/xml-in-laml.scm. DO NOT EDIT!

; lib/xml-in-laml/xml-in-laml.scm is not loaded here. 
; You must load it yourself prior to the loading of this file.

(define leno1-xml-transliterate-character-data? #t)
(define leno1-xml-char-transformation-table html-char-transformation-table)
(define leno1-xml-non-transliteration-elements '())
(define leno1-xml-preformatted-text-elements '())
(define leno1-xml-pass-default-dtd-attributes? #f)
(define leno1-xml-accept-only-string-valued-attributes? #t)
(define leno1-xml-accept-extended-contents? #f)
(define leno1-xml-document-type-declaration "")
(define leno1-xml-represent-white-space? #t)
(define leno1-xml-duplicated-attribute-handling 'keep-all)


; Empty temporary language map
(set! temp-language-map (quote ()))



;;; The validation procedures

(define (leno-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0) (dfa (quote (finite-state-automaton 0 (5) #((0 b 1) (1 c 2) (2 d 3) (2 e 4) (3 d 3) (3 e 4) (4 f 5)) #((begin-notes  . c) (end-notes  . e) (leno-front-matters  . b) (note-page  . d) (terminator$$  . f)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "leno"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "leno")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "leno"))))

(define (leno-front-matters-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("course-home-url" "CDATA" "#REQUIRED") ("author-home-url" "CDATA" "#REQUIRED") ("note-download-url" "CDATA" "#REQUIRED") ("logo-url" "CDATA" "#REQUIRED") ("note-contents-description" "CDATA" "#REQUIRED") ("slide-header" ("normal" "none" "minimal") "#REQUIRED") ("slide-view" ("true" "false") "true") ("annotated-slide-view" ("true" "false") "true") ("aggregated-view" ("true" "false") "true") ("theme-view" ("true" "false") "false") ("primary-view" ("slide-view" "annotated-slide-view" "aggregated-view") "slide-view") ("lecture-type" ("normal" "side-track") "#IMPLIED") ("scheme-prefix" "CDATA" "#IMPLIED") ("scheme-suffix" "CDATA" "#IMPLIED") ("trail-of-lecture" ("true" "false") "false") ("language" ("danish" "english") "english") ("show-and-speak" ("true" "false") "false") ("default-showing-time" "CDATA" "#IMPLIED") ("additional-showing-time" "CDATA" "#IMPLIED") ("sound-source" ("real-audio" "wave-file" "mp3-file") "#IMPLIED") ("speak-url-prefix" "CDATA" "#IMPLIED") ("speak-file-prefix" "CDATA" "#IMPLIED") ("show-and-speak-author-mode" ("true" "false") "false") ("exercise-model" ("none" "make-indexes" "make-indexes-and-solutions-per-lecture" "make-indexes-and-solutions-lecture-wide" "synchronous-exercises") "make-indexes-and-solutions-per-lecture") ("mouse-advancement" ("double-press" "single-press") "double-press") ("word-index" ("true" "false") "true") ("word-index-type" ("slide" "slide-and-theme") "slide") ("css-prestylesheet" "CDATA" "#IMPLIED") ("css-stylesheet" "CDATA" "#IMPLIED") ("css-stylesheet-copying" ("true" "false") "true") ("news-flash-string" "CDATA" "#IMPLIED") ("news-flash-level" "CDATA" "1") ("news-flash-url" "CDATA" "#IMPLIED") ("quiz-support" ("true" "false") "#IMPLIED") ("verbosity-level" "CDATA" "1") ("process-all-lectures" ("true" "false") "false") ("clean-html-directory" ("true" "false") "false") ("theme-source" ("overwrite" "new" "none" "delta") "none") ("theme-auto-process" ("true" "false") "false") ("make-print-page" ("true" "false") "false") ("trail-source" ("overwrite" "new" "none") "none") ("source-destination-delta" "CDATA" "html/") ("html-pdf-delta" "CDATA" "../pdf/") ("source-program-index" ("true" "false") "true") ("source-index-page" ("true" "false") "true") ("treat-svg-images-as" ("svg" "png" "png-if-exist") "svg") ("presentation-medium" ("web" "paper") "web") ("use-doc-comments" ("true" "false") "false") ("doc-comment-prefix" "CDATA" "#IMPLIED") ("use-note-page-importance" ("true" "false") "false") ("pdf-version-as-of" "CDATA" "#IMPLIED")))) (req-n 6) (dfa (quote (finite-state-automaton 0 (6) #((0 b 1) (1 c 2) (1 d 3) (2 d 3) (3 e 4) (4 f 5) (5 g 6)) #((front-abstract  . f) (front-affiliation  . e) (front-author  . d) (front-subtitle  . c) (front-title  . b) (terminator$$  . g)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "leno-front-matters"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "leno-front-matters")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "leno-front-matters"))))

(define (front-title-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0)) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "front-title"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "front-title")) (if xml-validate-contents? (validate-as-pcdata! contents "front-title"))))

(define (front-subtitle-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0)) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "front-subtitle"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "front-subtitle")) (if xml-validate-contents? (validate-as-pcdata! contents "front-subtitle"))))

(define (front-author-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0)) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "front-author"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "front-author")) (if xml-validate-contents? (validate-as-pcdata! contents "front-author"))))

(define (front-affiliation-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0)) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "front-affiliation"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "front-affiliation")) (if xml-validate-contents? (validate-as-pcdata! contents "front-affiliation"))))

(define (front-abstract-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0)) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "front-abstract"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "front-abstract")) (if xml-validate-contents? (validate-as-pcdata! contents "front-abstract"))))

(define (begin-notes-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0)) (xml-check-for-empty-contents! contents "begin-notes") (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "begin-notes"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "begin-notes"))))

(define (end-notes-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0)) (xml-check-for-empty-contents! contents "end-notes") (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "end-notes"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "end-notes"))))

(define (note-page-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("id" "CDATA" "#REQUIRED") ("drop" ("true" "false") "false") ("importance" "CDATA" "#IMPLIED")))) (req-n 1) (dfa (quote (finite-state-automaton 0 (12) #((0 b 1) (0 c 2) (1 d 38) (1 e 39) (1 f 40) (1 g 41) (1 h 42) (1 i 43) (1 j 44) (1 k 45) (1 l 46) (1 m 12) (2 ba 13) (2 bb 14) (2 bc 15) (2 bd 16) (2 be 17) (2 bf 18) (2 bg 19) (2 bh 20) (2 bi 21) (2 bj 22) (2 bk 23) (2 bl 24) (2 d 3) (2 e 4) (2 f 5) (2 g 6) (2 h 7) (2 i 8) (2 j 9) (2 k 10) (2 l 11) (2 m 12) (2 n 25) (2 o 26) (2 p 27) (2 q 28) (2 r 29) (2 s 30) (2 t 31) (2 u 32) (2 v 33) (2 w 34) (2 x 35) (2 y 36) (2 z 37) (3 ba 13) (3 bb 14) (3 bc 15) (3 bd 16) (3 be 17) (3 bf 18) (3 bg 19) (3 bh 20) (3 bi 21) (3 bj 22) (3 bk 23) (3 bl 24) (3 d 3) (3 e 4) (3 f 5) (3 g 6) (3 h 7) (3 i 8) (3 j 9) (3 k 10) (3 l 11) (3 m 12) (3 n 25) (3 o 26) (3 p 27) (3 q 28) (3 r 29) (3 s 30) (3 t 31) (3 u 32) (3 v 33) (3 w 34) (3 x 35) (3 y 36) (3 z 37) (4 ba 13) (4 bb 14) (4 bc 15) (4 bd 16) (4 be 17) (4 bf 18) (4 bg 19) (4 bh 20) (4 bi 21) (4 bj 22) (4 bk 23) (4 bl 24) (4 d 3) (4 e 4) (4 f 5) (4 g 6) (4 h 7) (4 i 8) (4 j 9) (4 k 10) (4 l 11) (4 m 12) (4 n 25) (4 o 26) (4 p 27) (4 q 28) (4 r 29) (4 s 30) (4 t 31) (4 u 32) (4 v 33) (4 w 34) (4 x 35) (4 y 36) (4 z 37) (5 ba 13) (5 bb 14) (5 bc 15) (5 bd 16) (5 be 17) (5 bf 18) (5 bg 19) (5 bh 20) (5 bi 21) (5 bj 22) (5 bk 23) (5 bl 24) (5 d 3) (5 e 4) (5 f 5) (5 g 6) (5 h 7) (5 i 8) (5 j 9) (5 k 10) (5 l 11) (5 m 12) (5 n 25) (5 o 26) (5 p 27) (5 q 28) (5 r 29) (5 s 30) (5 t 31) (5 u 32) (5 v 33) (5 w 34) (5 x 35) (5 y 36) (5 z 37) (6 ba 13) (6 bb 14) (6 bc 15) (6 bd 16) (6 be 17) (6 bf 18) (6 bg 19) (6 bh 20) (6 bi 21) (6 bj 22) (6 bk 23) (6 bl 24) (6 d 3) (6 e 4) (6 f 5) (6 g 6) (6 h 7) (6 i 8) (6 j 9) (6 k 10) (6 l 11) (6 m 12) (6 n 25) (6 o 26) (6 p 27) (6 q 28) (6 r 29) (6 s 30) (6 t 31) (6 u 32) (6 v 33) (6 w 34) (6 x 35) (6 y 36) (6 z 37) (7 ba 13) (7 bb 14) (7 bc 15) (7 bd 16) (7 be 17) (7 bf 18) (7 bg 19) (7 bh 20) (7 bi 21) (7 bj 22) (7 bk 23) (7 bl 24) (7 d 3) (7 e 4) (7 f 5) (7 g 6) (7 h 7) (7 i 8) (7 j 9) (7 k 10) (7 l 11) (7 m 12) (7 n 25) (7 o 26) (7 p 27) (7 q 28) (7 r 29) (7 s 30) (7 t 31) (7 u 32) (7 v 33) (7 w 34) (7 x 35) (7 y 36) (7 z 37) (8 ba 13) (8 bb 14) (8 bc 15) (8 bd 16) (8 be 17) (8 bf 18) (8 bg 19) (8 bh 20) (8 bi 21) (8 bj 22) (8 bk 23) (8 bl 24) (8 d 3) (8 e 4) (8 f 5) (8 g 6) (8 h 7) (8 i 8) (8 j 9) (8 k 10) (8 l 11) (8 m 12) (8 n 25) (8 o 26) (8 p 27) (8 q 28) (8 r 29) (8 s 30) (8 t 31) (8 u 32) (8 v 33) (8 w 34) (8 x 35) (8 y 36) (8 z 37) (9 ba 13) (9 bb 14) (9 bc 15) (9 bd 16) (9 be 17) (9 bf 18) (9 bg 19) (9 bh 20) (9 bi 21) (9 bj 22) (9 bk 23) (9 bl 24) (9 d 3) (9 e 4) (9 f 5) (9 g 6) (9 h 7) (9 i 8) (9 j 9) (9 k 10) (9 l 11) (9 m 12) (9 n 25) (9 o 26) (9 p 27) (9 q 28) (9 r 29) (9 s 30) (9 t 31) (9 u 32) (9 v 33) (9 w 34) (9 x 35) (9 y 36) (9 z 37) (10 ba 13) (10 bb 14) (10 bc 15) (10 bd 16) (10 be 17) (10 bf 18) (10 bg 19) (10 bh 20) (10 bi 21) (10 bj 22) (10 bk 23) (10 bl 24) (10 d 3) (10 e 4) (10 f 5) (10 g 6) (10 h 7) (10 i 8) (10 j 9) (10 k 10) (10 l 11) (10 m 12) (10 n 25) (10 o 26) (10 p 27) (10 q 28) (10 r 29) (10 s 30) (10 t 31) (10 u 32) (10 v 33) (10 w 34) (10 x 35) (10 y 36) (10 z 37) (11 ba 13) (11 bb 14) (11 bc 15) (11 bd 16) (11 be 17) (11 bf 18) (11 bg 19) (11 bh 20) (11 bi 21) (11 bj 22) (11 bk 23) (11 bl 24) (11 d 3) (11 e 4) (11 f 5) (11 g 6) (11 h 7) (11 i 8) (11 j 9) (11 k 10) (11 l 11) (11 m 12) (11 n 25) (11 o 26) (11 p 27) (11 q 28) (11 r 29) (11 s 30) (11 t 31) (11 u 32) (11 v 33) (11 w 34) (11 x 35) (11 y 36) (11 z 37) (13 ba 13) (13 bb 14) (13 bc 15) (13 bd 16) (13 be 17) (13 bf 18) (13 bg 19) (13 bh 20) (13 bi 21) (13 bj 22) (13 bk 23) (13 bl 24) (13 d 3) (13 e 4) (13 f 5) (13 g 6) (13 h 7) (13 i 8) (13 j 9) (13 k 10) (13 l 11) (13 m 12) (13 n 25) (13 o 26) (13 p 27) (13 q 28) (13 r 29) (13 s 30) (13 t 31) (13 u 32) (13 v 33) (13 w 34) (13 x 35) (13 y 36) (13 z 37) (14 ba 13) (14 bb 14) (14 bc 15) (14 bd 16) (14 be 17) (14 bf 18) (14 bg 19) (14 bh 20) (14 bi 21) (14 bj 22) (14 bk 23) (14 bl 24) (14 d 3) (14 e 4) (14 f 5) (14 g 6) (14 h 7) (14 i 8) (14 j 9) (14 k 10) (14 l 11) (14 m 12) (14 n 25) (14 o 26) (14 p 27) (14 q 28) (14 r 29) (14 s 30) (14 t 31) (14 u 32) (14 v 33) (14 w 34) (14 x 35) (14 y 36) (14 z 37) (15 ba 13) (15 bb 14) (15 bc 15) (15 bd 16) (15 be 17) (15 bf 18) (15 bg 19) (15 bh 20) (15 bi 21) (15 bj 22) (15 bk 23) (15 bl 24) (15 d 3) (15 e 4) (15 f 5) (15 g 6) (15 h 7) (15 i 8) (15 j 9) (15 k 10) (15 l 11) (15 m 12) (15 n 25) (15 o 26) (15 p 27) (15 q 28) (15 r 29) (15 s 30) (15 t 31) (15 u 32) (15 v 33) (15 w 34) (15 x 35) (15 y 36) (15 z 37) (16 ba 13) (16 bb 14) (16 bc 15) (16 bd 16) (16 be 17) (16 bf 18) (16 bg 19) (16 bh 20) (16 bi 21) (16 bj 22) (16 bk 23) (16 bl 24) (16 d 3) (16 e 4) (16 f 5) (16 g 6) (16 h 7) (16 i 8) (16 j 9) (16 k 10) (16 l 11) (16 m 12) (16 n 25) (16 o 26) (16 p 27) (16 q 28) (16 r 29) (16 s 30) (16 t 31) (16 u 32) (16 v 33) (16 w 34) (16 x 35) (16 y 36) (16 z 37) (17 ba 13) (17 bb 14) (17 bc 15) (17 bd 16) (17 be 17) (17 bf 18) (17 bg 19) (17 bh 20) (17 bi 21) (17 bj 22) (17 bk 23) (17 bl 24) (17 d 3) (17 e 4) (17 f 5) (17 g 6) (17 h 7) (17 i 8) (17 j 9) (17 k 10) (17 l 11) (17 m 12) (17 n 25) (17 o 26) (17 p 27) (17 q 28) (17 r 29) (17 s 30) (17 t 31) (17 u 32) (17 v 33) (17 w 34) (17 x 35) (17 y 36) (17 z 37) (18 ba 13) (18 bb 14) (18 bc 15) (18 bd 16) (18 be 17) (18 bf 18) (18 bg 19) (18 bh 20) (18 bi 21) (18 bj 22) (18 bk 23) (18 bl 24) (18 d 3) (18 e 4) (18 f 5) (18 g 6) (18 h 7) (18 i 8) (18 j 9) (18 k 10) (18 l 11) (18 m 12) (18 n 25) (18 o 26) (18 p 27) (18 q 28) (18 r 29) (18 s 30) (18 t 31) (18 u 32) (18 v 33) (18 w 34) (18 x 35) (18 y 36) (18 z 37) (19 ba 13) (19 bb 14) (19 bc 15) (19 bd 16) (19 be 17) (19 bf 18) (19 bg 19) (19 bh 20) (19 bi 21) (19 bj 22) (19 bk 23) (19 bl 24) (19 d 3) (19 e 4) (19 f 5) (19 g 6) (19 h 7) (19 i 8) (19 j 9) (19 k 10) (19 l 11) (19 m 12) (19 n 25) (19 o 26) (19 p 27) (19 q 28) (19 r 29) (19 s 30) (19 t 31) (19 u 32) (19 v 33) (19 w 34) (19 x 35) (19 y 36) (19 z 37) (20 ba 13) (20 bb 14) (20 bc 15) (20 bd 16) (20 be 17) (20 bf 18) (20 bg 19) (20 bh 20) (20 bi 21) (20 bj 22) (20 bk 23) (20 bl 24) (20 d 3) (20 e 4) (20 f 5) (20 g 6) (20 h 7) (20 i 8) (20 j 9) (20 k 10) (20 l 11) (20 m 12) (20 n 25) (20 o 26) (20 p 27) (20 q 28) (20 r 29) (20 s 30) (20 t 31) (20 u 32) (20 v 33) (20 w 34) (20 x 35) (20 y 36) (20 z 37) (21 ba 13) (21 bb 14) (21 bc 15) (21 bd 16) (21 be 17) (21 bf 18) (21 bg 19) (21 bh 20) (21 bi 21) (21 bj 22) (21 bk 23) (21 bl 24) (21 d 3) (21 e 4) (21 f 5) (21 g 6) (21 h 7) (21 i 8) (21 j 9) (21 k 10) (21 l 11) (21 m 12) (21 n 25) (21 o 26) (21 p 27) (21 q 28) (21 r 29) (21 s 30) (21 t 31) (21 u 32) (21 v 33) (21 w 34) (21 x 35) (21 y 36) (21 z 37) (22 ba 13) (22 bb 14) (22 bc 15) (22 bd 16) (22 be 17) (22 bf 18) (22 bg 19) (22 bh 20) (22 bi 21) (22 bj 22) (22 bk 23) (22 bl 24) (22 d 3) (22 e 4) (22 f 5) (22 g 6) (22 h 7) (22 i 8) (22 j 9) (22 k 10) (22 l 11) (22 m 12) (22 n 25) (22 o 26) (22 p 27) (22 q 28) (22 r 29) (22 s 30) (22 t 31) (22 u 32) (22 v 33) (22 w 34) (22 x 35) (22 y 36) (22 z 37) (23 ba 13) (23 bb 14) (23 bc 15) (23 bd 16) (23 be 17) (23 bf 18) (23 bg 19) (23 bh 20) (23 bi 21) (23 bj 22) (23 bk 23) (23 bl 24) (23 d 3) (23 e 4) (23 f 5) (23 g 6) (23 h 7) (23 i 8) (23 j 9) (23 k 10) (23 l 11) (23 m 12) (23 n 25) (23 o 26) (23 p 27) (23 q 28) (23 r 29) (23 s 30) (23 t 31) (23 u 32) (23 v 33) (23 w 34) (23 x 35) (23 y 36) (23 z 37) (24 ba 13) (24 bb 14) (24 bc 15) (24 bd 16) (24 be 17) (24 bf 18) (24 bg 19) (24 bh 20) (24 bi 21) (24 bj 22) (24 bk 23) (24 bl 24) (24 d 3) (24 e 4) (24 f 5) (24 g 6) (24 h 7) (24 i 8) (24 j 9) (24 k 10) (24 l 11) (24 m 12) (24 n 25) (24 o 26) (24 p 27) (24 q 28) (24 r 29) (24 s 30) (24 t 31) (24 u 32) (24 v 33) (24 w 34) (24 x 35) (24 y 36) (24 z 37) (25 ba 13) (25 bb 14) (25 bc 15) (25 bd 16) (25 be 17) (25 bf 18) (25 bg 19) (25 bh 20) (25 bi 21) (25 bj 22) (25 bk 23) (25 bl 24) (25 d 3) (25 e 4) (25 f 5) (25 g 6) (25 h 7) (25 i 8) (25 j 9) (25 k 10) (25 l 11) (25 m 12) (25 n 25) (25 o 26) (25 p 27) (25 q 28) (25 r 29) (25 s 30) (25 t 31) (25 u 32) (25 v 33) (25 w 34) (25 x 35) (25 y 36) (25 z 37) (26 ba 13) (26 bb 14) (26 bc 15) (26 bd 16) (26 be 17) (26 bf 18) (26 bg 19) (26 bh 20) (26 bi 21) (26 bj 22) (26 bk 23) (26 bl 24) (26 d 3) (26 e 4) (26 f 5) (26 g 6) (26 h 7) (26 i 8) (26 j 9) (26 k 10) (26 l 11) (26 m 12) (26 n 25) (26 o 26) (26 p 27) (26 q 28) (26 r 29) (26 s 30) (26 t 31) (26 u 32) (26 v 33) (26 w 34) (26 x 35) (26 y 36) (26 z 37) (27 ba 13) (27 bb 14) (27 bc 15) (27 bd 16) (27 be 17) (27 bf 18) (27 bg 19) (27 bh 20) (27 bi 21) (27 bj 22) (27 bk 23) (27 bl 24) (27 d 3) (27 e 4) (27 f 5) (27 g 6) (27 h 7) (27 i 8) (27 j 9) (27 k 10) (27 l 11) (27 m 12) (27 n 25) (27 o 26) (27 p 27) (27 q 28) (27 r 29) (27 s 30) (27 t 31) (27 u 32) (27 v 33) (27 w 34) (27 x 35) (27 y 36) (27 z 37) (28 ba 13) (28 bb 14) (28 bc 15) (28 bd 16) (28 be 17) (28 bf 18) (28 bg 19) (28 bh 20) (28 bi 21) (28 bj 22) (28 bk 23) (28 bl 24) (28 d 3) (28 e 4) (28 f 5) (28 g 6) (28 h 7) (28 i 8) (28 j 9) (28 k 10) (28 l 11) (28 m 12) (28 n 25) (28 o 26) (28 p 27) (28 q 28) (28 r 29) (28 s 30) (28 t 31) (28 u 32) (28 v 33) (28 w 34) (28 x 35) (28 y 36) (28 z 37) (29 ba 13) (29 bb 14) (29 bc 15) (29 bd 16) (29 be 17) (29 bf 18) (29 bg 19) (29 bh 20) (29 bi 21) (29 bj 22) (29 bk 23) (29 bl 24) (29 d 3) (29 e 4) (29 f 5) (29 g 6) (29 h 7) (29 i 8) (29 j 9) (29 k 10) (29 l 11) (29 m 12) (29 n 25) (29 o 26) (29 p 27) (29 q 28) (29 r 29) (29 s 30) (29 t 31) (29 u 32) (29 v 33) (29 w 34) (29 x 35) (29 y 36) (29 z 37) (30 ba 13) (30 bb 14) (30 bc 15) (30 bd 16) (30 be 17) (30 bf 18) (30 bg 19) (30 bh 20) (30 bi 21) (30 bj 22) (30 bk 23) (30 bl 24) (30 d 3) (30 e 4) (30 f 5) (30 g 6) (30 h 7) (30 i 8) (30 j 9) (30 k 10) (30 l 11) (30 m 12) (30 n 25) (30 o 26) (30 p 27) (30 q 28) (30 r 29) (30 s 30) (30 t 31) (30 u 32) (30 v 33) (30 w 34) (30 x 35) (30 y 36) (30 z 37) (31 ba 13) (31 bb 14) (31 bc 15) (31 bd 16) (31 be 17) (31 bf 18) (31 bg 19) (31 bh 20) (31 bi 21) (31 bj 22) (31 bk 23) (31 bl 24) (31 d 3) (31 e 4) (31 f 5) (31 g 6) (31 h 7) (31 i 8) (31 j 9) (31 k 10) (31 l 11) (31 m 12) (31 n 25) (31 o 26) (31 p 27) (31 q 28) (31 r 29) (31 s 30) (31 t 31) (31 u 32) (31 v 33) (31 w 34) (31 x 35) (31 y 36) (31 z 37) (32 ba 13) (32 bb 14) (32 bc 15) (32 bd 16) (32 be 17) (32 bf 18) (32 bg 19) (32 bh 20) (32 bi 21) (32 bj 22) (32 bk 23) (32 bl 24) (32 d 3) (32 e 4) (32 f 5) (32 g 6) (32 h 7) (32 i 8) (32 j 9) (32 k 10) (32 l 11) (32 m 12) (32 n 25) (32 o 26) (32 p 27) (32 q 28) (32 r 29) (32 s 30) (32 t 31) (32 u 32) (32 v 33) (32 w 34) (32 x 35) (32 y 36) (32 z 37) (33 ba 13) (33 bb 14) (33 bc 15) (33 bd 16) (33 be 17) (33 bf 18) (33 bg 19) (33 bh 20) (33 bi 21) (33 bj 22) (33 bk 23) (33 bl 24) (33 d 3) (33 e 4) (33 f 5) (33 g 6) (33 h 7) (33 i 8) (33 j 9) (33 k 10) (33 l 11) (33 m 12) (33 n 25) (33 o 26) (33 p 27) (33 q 28) (33 r 29) (33 s 30) (33 t 31) (33 u 32) (33 v 33) (33 w 34) (33 x 35) (33 y 36) (33 z 37) (34 ba 13) (34 bb 14) (34 bc 15) (34 bd 16) (34 be 17) (34 bf 18) (34 bg 19) (34 bh 20) (34 bi 21) (34 bj 22) (34 bk 23) (34 bl 24) (34 d 3) (34 e 4) (34 f 5) (34 g 6) (34 h 7) (34 i 8) (34 j 9) (34 k 10) (34 l 11) (34 m 12) (34 n 25) (34 o 26) (34 p 27) (34 q 28) (34 r 29) (34 s 30) (34 t 31) (34 u 32) (34 v 33) (34 w 34) (34 x 35) (34 y 36) (34 z 37) (35 ba 13) (35 bb 14) (35 bc 15) (35 bd 16) (35 be 17) (35 bf 18) (35 bg 19) (35 bh 20) (35 bi 21) (35 bj 22) (35 bk 23) (35 bl 24) (35 d 3) (35 e 4) (35 f 5) (35 g 6) (35 h 7) (35 i 8) (35 j 9) (35 k 10) (35 l 11) (35 m 12) (35 n 25) (35 o 26) (35 p 27) (35 q 28) (35 r 29) (35 s 30) (35 t 31) (35 u 32) (35 v 33) (35 w 34) (35 x 35) (35 y 36) (35 z 37) (36 ba 13) (36 bb 14) (36 bc 15) (36 bd 16) (36 be 17) (36 bf 18) (36 bg 19) (36 bh 20) (36 bi 21) (36 bj 22) (36 bk 23) (36 bl 24) (36 d 3) (36 e 4) (36 f 5) (36 g 6) (36 h 7) (36 i 8) (36 j 9) (36 k 10) (36 l 11) (36 m 12) (36 n 25) (36 o 26) (36 p 27) (36 q 28) (36 r 29) (36 s 30) (36 t 31) (36 u 32) (36 v 33) (36 w 34) (36 x 35) (36 y 36) (36 z 37) (37 ba 13) (37 bb 14) (37 bc 15) (37 bd 16) (37 be 17) (37 bf 18) (37 bg 19) (37 bh 20) (37 bi 21) (37 bj 22) (37 bk 23) (37 bl 24) (37 d 3) (37 e 4) (37 f 5) (37 g 6) (37 h 7) (37 i 8) (37 j 9) (37 k 10) (37 l 11) (37 m 12) (37 n 25) (37 o 26) (37 p 27) (37 q 28) (37 r 29) (37 s 30) (37 t 31) (37 u 32) (37 v 33) (37 w 34) (37 x 35) (37 y 36) (37 z 37) (38 d 38) (38 e 39) (38 f 40) (38 g 41) (38 h 42) (38 i 43) (38 j 44) (38 k 45) (38 l 46) (38 m 12) (39 d 38) (39 e 39) (39 f 40) (39 g 41) (39 h 42) (39 i 43) (39 j 44) (39 k 45) (39 l 46) (39 m 12) (40 d 38) (40 e 39) (40 f 40) (40 g 41) (40 h 42) (40 i 43) (40 j 44) (40 k 45) (40 l 46) (40 m 12) (41 d 38) (41 e 39) (41 f 40) (41 g 41) (41 h 42) (41 i 43) (41 j 44) (41 k 45) (41 l 46) (41 m 12) (42 d 38) (42 e 39) (42 f 40) (42 g 41) (42 h 42) (42 i 43) (42 j 44) (42 k 45) (42 l 46) (42 m 12) (43 d 38) (43 e 39) (43 f 40) (43 g 41) (43 h 42) (43 i 43) (43 j 44) (43 k 45) (43 l 46) (43 m 12) (44 d 38) (44 e 39) (44 f 40) (44 g 41) (44 h 42) (44 i 43) (44 j 44) (44 k 45) (44 l 46) (44 m 12) (45 d 38) (45 e 39) (45 f 40) (45 g 41) (45 h 42) (45 i 43) (45 j 44) (45 k 45) (45 l 46) (45 m 12) (46 d 38) (46 e 39) (46 f 40) (46 g 41) (46 h 42) (46 i 43) (46 j 44) (46 k 45) (46 l 46) (46 m 12)) #((applet-program  . bh) (comment  . i) (concept-list  . bi) (cross-references  . y) (elucidate  . bc) (example  . s) (exercise  . z) (flash-image  . bk) (image  . r) (image-series  . ba) (index-words  . j) (items  . p) (language-syntax  . u) (lecturer-photos  . e) (lecturer-photos-and-logo  . f) (meta-text  . bl) (note-text  . w) (opposing  . t) (point  . o) (quiz  . k) (quotation  . bf) (section-title  . b) (show-and-speak  . d) (side-track  . bd) (slide-image  . bb) (slide-space  . be) (slide-text  . x) (source-program  . q) (splice-page-with  . g) (splice-page-without  . h) (svg-image  . bj) (synopsis  . bg) (tabular  . v) (terminator$$  . m) (text  . n) (theme-text  . l) (title  . c)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "note-page"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "note-page")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "note-page"))))

(define (title-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("id" "ID" "#IMPLIED") ("margin" "CDATA" "#IMPLIED") ("margin-left" "CDATA" "#IMPLIED") ("margin-right" "CDATA" "#IMPLIED") ("margin-bottom" "CDATA" "#IMPLIED") ("margin-top" "CDATA" "#IMPLIED") ("drop" ("true" "false") "false") ("annotations" ("unfold-before" "unfold-after" "keep" "merge" "ignore") "unfold-after")))) (req-n 0) (dfa (quote (finite-state-automaton 0 (3) #((0 b 1) (1 c 2) (1 d 3) (2 d 3)) #((annotation  . c) (main-text  . b) (terminator$$  . d)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "title"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "title")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "title"))))

(define (main-text-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0)) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "main-text"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "main-text")) (if xml-validate-contents? (validate-as-pcdata! contents "main-text"))))

(define (annotation-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0)) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "annotation"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "annotation")) (if xml-validate-contents? (validate-as-pcdata! contents "annotation"))))

(define (section-title-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("id" "ID" "#IMPLIED")))) (req-n 0)) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "section-title"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "section-title")) (if xml-validate-contents? (validate-as-pcdata! contents "section-title"))))

(define (point-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("id" "ID" "#IMPLIED") ("margin" "CDATA" "#IMPLIED") ("margin-left" "CDATA" "#IMPLIED") ("margin-right" "CDATA" "#IMPLIED") ("margin-bottom" "CDATA" "#IMPLIED") ("margin-top" "CDATA" "#IMPLIED") ("drop" ("true" "false") "false") ("annotations" ("unfold-before" "unfold-after" "keep" "merge" "ignore") "unfold-after")))) (req-n 0) (dfa (quote (finite-state-automaton 0 (3) #((0 b 1) (1 c 2) (1 d 3) (2 d 3)) #((annotation  . c) (main-text  . b) (terminator$$  . d)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "point"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "point")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "point"))))

(define (items-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("id" "ID" "#IMPLIED") ("margin" "CDATA" "#IMPLIED") ("margin-left" "CDATA" "#IMPLIED") ("margin-right" "CDATA" "#IMPLIED") ("margin-bottom" "CDATA" "#IMPLIED") ("margin-top" "CDATA" "#IMPLIED") ("drop" ("true" "false") "false") ("annotations" ("unfold-before" "unfold-after" "keep" "merge" "ignore") "unfold-after")))) (req-n 0) (dfa (quote (finite-state-automaton 0 (2) #((0 b 1) (0 c 2) (1 b 1) (1 c 2)) #((item  . b) (terminator$$  . c)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "items"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "items")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "items"))))

(define (item-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("id" "ID" "#IMPLIED") ("drop" ("true" "false") "false") ("annotations" ("unfold-before" "unfold-after" "keep" "merge" "ignore") "unfold-after")))) (req-n 0) (dfa (quote (finite-state-automaton 0 (4) #((0 b 1) (1 c 2) (1 d 3) (1 e 4) (2 d 3) (2 e 4) (3 e 4)) #((annotation  . c) (items  . d) (main-text  . b) (terminator$$  . e)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "item"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "item")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "item"))))

(define (source-program-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("src" "CDATA" "#REQUIRED") ("id" "ID" "#IMPLIED") ("margin" "CDATA" "#IMPLIED") ("margin-left" "CDATA" "#IMPLIED") ("margin-right" "CDATA" "#IMPLIED") ("margin-bottom" "CDATA" "#IMPLIED") ("margin-top" "CDATA" "#IMPLIED") ("drop" ("true" "false") "false") ("from-mark" "CDATA" "#IMPLIED") ("to-mark" "CDATA" "#IMPLIED") ("slide-mode" ("inline" "external") "inline") ("book-mode" ("inline" "external") "inline") ("background-color" "CDATA" "#IMPLIED") ("indexed" ("true" "false") "true") ("index-title" "CDATA" "#IMPLIED") ("kind" ("source-program" "listing") "source-program") ("program-annotations" ("true" "false") "true")))) (req-n 1) (dfa (quote (finite-state-automaton 0 (4) #((0 b 1) (0 c 2) (1 c 2) (2 d 3) (2 e 4) (3 e 4)) #((annotation  . d) (color-decorations  . b) (main-text  . c) (terminator$$  . e)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "source-program"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "source-program")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "source-program"))))

(define (color-decorations-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0) (dfa (quote (finite-state-automaton 0 (2) #((0 b 1) (0 c 2) (1 b 1) (1 c 2)) #((color-decoration  . b) (terminator$$  . c)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "color-decorations"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "color-decorations")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "color-decorations"))))

(define (color-decoration-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("from-mark" "CDATA" "#REQUIRED") ("to-mark" "CDATA" "#REQUIRED") ("color" "CDATA" "#REQUIRED") ("face" ("bold" "italic" "typewriter" "underlined" "plain") "#IMPLIED") ("repetition" "CDATA" "#IMPLIED")))) (req-n 3)) (xml-check-for-empty-contents! contents "color-decoration") (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "color-decoration"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "color-decoration"))))

(define (image-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("src" "CDATA" "#REQUIRED") ("id" "ID" "#IMPLIED") ("margin" "CDATA" "#IMPLIED") ("margin-left" "CDATA" "#IMPLIED") ("margin-right" "CDATA" "#IMPLIED") ("margin-bottom" "CDATA" "#IMPLIED") ("margin-top" "CDATA" "#IMPLIED") ("drop" ("true" "false") "false") ("alignment" ("vertical" "horizontal") "#IMPLIED") ("first" ("picture" "text") "#IMPLIED") ("second" ("picture" "text") "#IMPLIED")))) (req-n 1) (dfa (quote (finite-state-automaton 0 (2) #((0 b 1) (1 c 2)) #((main-text  . b) (terminator$$  . c)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "image"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "image")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "image"))))

(define (concept-list-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("id" "ID" "#IMPLIED") ("margin" "CDATA" "#IMPLIED") ("margin-left" "CDATA" "#IMPLIED") ("margin-right" "CDATA" "#IMPLIED") ("margin-bottom" "CDATA" "#IMPLIED") ("margin-top" "CDATA" "#IMPLIED") ("drop" ("true" "false") "false")))) (req-n 0) (dfa (quote (finite-state-automaton 0 (3) #((0 b 1) (1 b 2) (1 c 3) (2 b 2) (2 c 3)) #((concept  . b) (terminator$$  . c)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "concept-list"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "concept-list")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "concept-list"))))

(define (concept-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("concept-name" "CDATA" "#REQUIRED") ("id" "ID" "#IMPLIED") ("annotations" ("unfold-before" "unfold-after" "keep" "merge" "ignore") "unfold-after")))) (req-n 1) (dfa (quote (finite-state-automaton 0 (3) #((0 b 1) (1 c 2) (1 d 3) (2 d 3)) #((annotation  . c) (main-text  . b) (terminator$$  . d)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "concept"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "concept")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "concept"))))

(define (example-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("id" "ID" "#IMPLIED") ("margin" "CDATA" "#IMPLIED") ("margin-left" "CDATA" "#IMPLIED") ("margin-right" "CDATA" "#IMPLIED") ("margin-bottom" "CDATA" "#IMPLIED") ("margin-top" "CDATA" "#IMPLIED") ("drop" ("true" "false") "false") ("annotations" ("unfold-before" "unfold-after" "keep" "merge" "ignore") "unfold-after")))) (req-n 0) (dfa (quote (finite-state-automaton 0 (3) #((0 b 1) (1 c 2) (1 d 3) (2 d 3)) #((annotation  . c) (main-text  . b) (terminator$$  . d)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "example"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "example")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "example"))))

(define (opposing-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("id" "ID" "#IMPLIED") ("margin" "CDATA" "#IMPLIED") ("margin-left" "CDATA" "#IMPLIED") ("margin-right" "CDATA" "#IMPLIED") ("margin-bottom" "CDATA" "#IMPLIED") ("margin-top" "CDATA" "#IMPLIED") ("drop" ("true" "false") "false")))) (req-n 0) (dfa (quote (finite-state-automaton 0 (3) #((0 b 1) (1 b 2) (1 c 3) (2 b 2) (2 c 3)) #((opposing-item  . b) (terminator$$  . c)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "opposing"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "opposing")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "opposing"))))

(define (opposing-item-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0) (dfa (quote (finite-state-automaton 0 (3) #((0 b 1) (1 c 2) (2 d 3)) #((left-item  . b) (right-item  . c) (terminator$$  . d)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "opposing-item"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "opposing-item")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "opposing-item"))))

(define (left-item-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0)) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "left-item"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "left-item")) (if xml-validate-contents? (validate-as-pcdata! contents "left-item"))))

(define (right-item-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0)) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "right-item"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "right-item")) (if xml-validate-contents? (validate-as-pcdata! contents "right-item"))))

(define (comment-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("drop" ("true" "false") "false")))) (req-n 0)) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "comment"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "comment")) (if xml-validate-contents? (validate-as-pcdata! contents "comment"))))

(define (language-syntax-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("id" "ID" "#IMPLIED") ("margin" "CDATA" "#IMPLIED") ("margin-left" "CDATA" "#IMPLIED") ("margin-right" "CDATA" "#IMPLIED") ("margin-bottom" "CDATA" "#IMPLIED") ("margin-top" "CDATA" "#IMPLIED") ("drop" ("true" "false") "false") ("annotations" ("unfold-before" "unfold-after" "keep" "merge" "ignore") "unfold-after")))) (req-n 0) (dfa (quote (finite-state-automaton 0 (3) #((0 b 1) (1 c 2) (1 d 3) (2 d 3)) #((annotation  . c) (main-text  . b) (terminator$$  . d)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "language-syntax"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "language-syntax")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "language-syntax"))))

(define (tabular-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("id" "ID" "#IMPLIED") ("margin" "CDATA" "#IMPLIED") ("margin-left" "CDATA" "#IMPLIED") ("margin-right" "CDATA" "#IMPLIED") ("margin-bottom" "CDATA" "#IMPLIED") ("margin-top" "CDATA" "#IMPLIED") ("drop" ("true" "false") "false") ("border" "CDATA" "#IMPLIED") ("annotations" ("unfold-before" "unfold-after" "keep" "merge" "ignore") "unfold-after")))) (req-n 0) (dfa (quote (finite-state-automaton 0 (4) #((0 b 1) (1 c 2) (1 d 3) (1 e 4) (2 c 2) (2 d 3) (2 e 4) (3 e 4)) #((annotation  . d) (row  . c) (row-widths  . b) (terminator$$  . e)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "tabular"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "tabular")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "tabular"))))

(define (row-widths-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0) (dfa (quote (finite-state-automaton 0 (2) #((0 b 1) (0 c 2) (1 b 1) (1 c 2)) #((cell  . b) (terminator$$  . c)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "row-widths"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "row-widths")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "row-widths"))))

(define (row-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0) (dfa (quote (finite-state-automaton 0 (2) #((0 b 1) (0 c 2) (1 b 1) (1 c 2)) #((cell  . b) (terminator$$  . c)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "row"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "row")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "row"))))

(define (cell-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0)) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "cell"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "cell")) (if xml-validate-contents? (validate-as-pcdata! contents "cell"))))

(define (text-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("id" "ID" "#IMPLIED") ("margin" "CDATA" "#IMPLIED") ("margin-left" "CDATA" "#IMPLIED") ("margin-right" "CDATA" "#IMPLIED") ("margin-bottom" "CDATA" "#IMPLIED") ("margin-top" "CDATA" "#IMPLIED") ("drop" ("true" "false") "false") ("annotations" ("unfold-before" "unfold-after" "keep" "merge" "ignore") "unfold-after")))) (req-n 0) (dfa (quote (finite-state-automaton 0 (3) #((0 b 1) (1 c 2) (1 d 3) (2 d 3)) #((annotation  . c) (main-text  . b) (terminator$$  . d)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "text"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "text")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "text"))))

(define (note-text-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("id" "ID" "#IMPLIED") ("margin" "CDATA" "#IMPLIED") ("margin-left" "CDATA" "#IMPLIED") ("margin-right" "CDATA" "#IMPLIED") ("margin-bottom" "CDATA" "#IMPLIED") ("margin-top" "CDATA" "#IMPLIED") ("drop" ("true" "false") "false")))) (req-n 0)) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "note-text"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "note-text")) (if xml-validate-contents? (validate-as-pcdata! contents "note-text"))))

(define (slide-text-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("id" "ID" "#IMPLIED") ("margin" "CDATA" "#IMPLIED") ("margin-left" "CDATA" "#IMPLIED") ("margin-right" "CDATA" "#IMPLIED") ("margin-bottom" "CDATA" "#IMPLIED") ("margin-top" "CDATA" "#IMPLIED") ("drop" ("true" "false") "false")))) (req-n 0)) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "slide-text"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "slide-text")) (if xml-validate-contents? (validate-as-pcdata! contents "slide-text"))))

(define (cross-references-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("id" "ID" "#IMPLIED") ("margin" "CDATA" "#IMPLIED") ("margin-left" "CDATA" "#IMPLIED") ("margin-right" "CDATA" "#IMPLIED") ("margin-bottom" "CDATA" "#IMPLIED") ("margin-top" "CDATA" "#IMPLIED") ("drop" ("true" "false") "false")))) (req-n 0) (dfa (quote (finite-state-automaton 0 (5) #((0 b 1) (0 c 2) (0 d 3) (0 e 4) (0 f 5) (1 b 1) (1 c 2) (1 d 3) (1 e 4) (1 f 5) (2 b 1) (2 c 2) (2 d 3) (2 e 4) (2 f 5) (3 b 1) (3 c 2) (3 d 3) (3 e 4) (3 f 5) (4 b 1) (4 c 2) (4 d 3) (4 e 4) (4 f 5)) #((bibtex-reference  . e) (informal-reference  . d) (internet-reference  . b) (note-reference  . c) (terminator$$  . f)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "cross-references"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "cross-references")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "cross-references"))))

(define (internet-reference-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("href" "CDATA" "#REQUIRED") ("id" "CDATA" "#IMPLIED") ("target" "CDATA" "#IMPLIED")))) (req-n 1) (dfa (quote (finite-state-automaton 0 (3) #((0 b 1) (1 c 2) (1 d 3) (2 d 3)) #((location-hints  . c) (main-text  . b) (terminator$$  . d)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "internet-reference"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "internet-reference")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "internet-reference"))))

(define (note-reference-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("lecture-id" "CDATA" "#REQUIRED") ("page-id" "CDATA" "#REQUIRED") ("id" "CDATA" "#IMPLIED")))) (req-n 2) (dfa (quote (finite-state-automaton 0 (3) #((0 b 1) (1 c 2) (1 d 3) (2 d 3)) #((location-hints  . c) (main-text  . b) (terminator$$  . d)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "note-reference"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "note-reference")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "note-reference"))))

(define (informal-reference-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("title" "CDATA" "#REQUIRED") ("id" "CDATA" "#IMPLIED")))) (req-n 1) (dfa (quote (finite-state-automaton 0 (3) #((0 b 1) (1 c 2) (1 d 3) (2 d 3)) #((location-hints  . c) (main-text  . b) (terminator$$  . d)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "informal-reference"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "informal-reference")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "informal-reference"))))

(define (bibtex-reference-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("key" "CDATA" "#REQUIRED")))) (req-n 1) (dfa (quote (finite-state-automaton 0 (2) #((0 b 1) (0 c 2) (1 c 2)) #((location-hints  . b) (terminator$$  . c)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "bibtex-reference"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "bibtex-reference")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "bibtex-reference"))))

(define (location-hints-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0) (dfa (quote (finite-state-automaton 0 (3) #((0 b 1) (1 b 2) (1 c 3) (2 b 2) (2 c 3)) #((hint  . b) (terminator$$  . c)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "location-hints"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "location-hints")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "location-hints"))))

(define (hint-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0)) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "hint"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "hint")) (if xml-validate-contents? (validate-as-pcdata! contents "hint"))))

(define (exercise-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("id" "CDATA" "#REQUIRED") ("title" "CDATA" "#REQUIRED") ("rank" "CDATA" "#IMPLIED")))) (req-n 2) (dfa (quote (finite-state-automaton 0 (3) #((0 b 1) (1 c 2) (1 d 3) (2 d 3)) #((formulation  . b) (solution  . c) (terminator$$  . d)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "exercise"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "exercise")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "exercise"))))

(define (formulation-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0)) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "formulation"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "formulation")) (if xml-validate-contents? (validate-as-pcdata! contents "formulation"))))

(define (solution-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0)) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "solution"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "solution")) (if xml-validate-contents? (validate-as-pcdata! contents "solution"))))

(define (index-words-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("drop" ("true" "false") "false")))) (req-n 0) (dfa (quote (finite-state-automaton 0 (2) #((0 b 1) (0 c 2) (1 b 1) (1 c 2)) #((index-word  . b) (terminator$$  . c)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "index-words"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "index-words")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "index-words"))))

(define (index-word-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0)) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "index-word"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "index-word")) (if xml-validate-contents? (validate-as-pcdata! contents "index-word"))))

(define (image-series-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("title" "CDATA" "#REQUIRED") ("id" "ID" "#IMPLIED") ("margin" "CDATA" "#IMPLIED") ("margin-left" "CDATA" "#IMPLIED") ("margin-right" "CDATA" "#IMPLIED") ("margin-bottom" "CDATA" "#IMPLIED") ("margin-top" "CDATA" "#IMPLIED") ("drop" ("true" "false") "false") ("slide-mode" ("inline" "external") "#IMPLIED") ("book-mode" ("inline" "external") "#IMPLIED")))) (req-n 1) (dfa (quote (finite-state-automaton 0 (2) #((0 b 1) (0 c 2) (1 b 1) (1 c 2)) #((image-series-item  . b) (terminator$$  . c)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "image-series"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "image-series")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "image-series"))))

(define (image-series-item-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("src" "CDATA" "#REQUIRED")))) (req-n 1)) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "image-series-item"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "image-series-item")) (if xml-validate-contents? (validate-as-pcdata! contents "image-series-item"))))

(define (slide-image-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("src" "CDATA" "#REQUIRED") ("id" "ID" "#IMPLIED") ("margin" "CDATA" "#IMPLIED") ("margin-left" "CDATA" "#IMPLIED") ("margin-right" "CDATA" "#IMPLIED") ("margin-bottom" "CDATA" "#IMPLIED") ("margin-top" "CDATA" "#IMPLIED") ("drop" ("true" "false") "false")))) (req-n 1)) (xml-check-for-empty-contents! contents "slide-image") (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "slide-image"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "slide-image"))))

(define (show-and-speak-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("drop" ("true" "false") "false")))) (req-n 0) (dfa (quote (finite-state-automaton 0 (4) #((0 b 1) (0 c 2) (0 d 3) (0 e 4) (1 b 1) (1 c 2) (1 d 3) (1 e 4) (2 b 1) (2 c 2) (2 d 3) (2 e 4) (3 b 1) (3 c 2) (3 d 3) (3 e 4)) #((image-series-part  . d) (program-part  . c) (slide-part  . b) (terminator$$  . e)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "show-and-speak"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "show-and-speak")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "show-and-speak"))))

(define (slide-part-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("number" "CDATA" "#REQUIRED") ("seconds" "CDATA" "#REQUIRED")))) (req-n 2)) (xml-check-for-empty-contents! contents "slide-part") (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "slide-part"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "slide-part"))))

(define (program-part-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("number" "CDATA" "#REQUIRED") ("seconds" "CDATA" "#REQUIRED")))) (req-n 2)) (xml-check-for-empty-contents! contents "program-part") (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "program-part"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "program-part"))))

(define (image-series-part-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("number" "CDATA" "#REQUIRED")))) (req-n 1) (dfa (quote (finite-state-automaton 0 (2) #((0 b 1) (0 c 2) (1 b 1) (1 c 2)) #((image-part  . b) (terminator$$  . c)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "image-series-part"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "image-series-part")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "image-series-part"))))

(define (image-part-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("seconds" "CDATA" "#REQUIRED")))) (req-n 1)) (xml-check-for-empty-contents! contents "image-part") (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "image-part"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "image-part"))))

(define (lecturer-photos-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("start-number" "CDATA" "#REQUIRED") ("number-of-photos" "CDATA" "#REQUIRED") ("id" "ID" "#IMPLIED") ("margin" "CDATA" "#IMPLIED") ("margin-left" "CDATA" "#IMPLIED") ("margin-right" "CDATA" "#IMPLIED") ("margin-bottom" "CDATA" "#IMPLIED") ("margin-top" "CDATA" "#IMPLIED") ("drop" ("true" "false") "false")))) (req-n 2)) (xml-check-for-empty-contents! contents "lecturer-photos") (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "lecturer-photos"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "lecturer-photos"))))

(define (lecturer-photos-and-logo-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("start-number" "CDATA" "#REQUIRED") ("id" "ID" "#IMPLIED") ("margin" "CDATA" "#IMPLIED") ("margin-left" "CDATA" "#IMPLIED") ("margin-right" "CDATA" "#IMPLIED") ("margin-bottom" "CDATA" "#IMPLIED") ("margin-top" "CDATA" "#IMPLIED") ("drop" ("true" "false") "false")))) (req-n 1)) (xml-check-for-empty-contents! contents "lecturer-photos-and-logo") (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "lecturer-photos-and-logo"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "lecturer-photos-and-logo"))))

(define (elucidate-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("href" "CDATA" "#REQUIRED") ("id" "ID" "#IMPLIED") ("margin" "CDATA" "#IMPLIED") ("margin-left" "CDATA" "#IMPLIED") ("margin-right" "CDATA" "#IMPLIED") ("margin-bottom" "CDATA" "#IMPLIED") ("margin-top" "CDATA" "#IMPLIED") ("drop" ("true" "false") "false") ("target" "CDATA" "#IMPLIED")))) (req-n 1)) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "elucidate"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "elucidate")) (if xml-validate-contents? (validate-as-pcdata! contents "elucidate"))))

(define (splice-page-with-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("lecture-id" "CDATA" "#REQUIRED") ("page-id" "CDATA" "#REQUIRED") ("drop" ("true" "false") "false") ("element-id" "CDATA" "#IMPLIED")))) (req-n 2) (dfa (quote (finite-state-automaton 0 (2) #((0 b 1) (1 c 2)) #((leno-elements  . b) (terminator$$  . c)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "splice-page-with"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "splice-page-with")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "splice-page-with"))))

(define (splice-page-without-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("lecture-id" "CDATA" "#REQUIRED") ("page-id" "CDATA" "#REQUIRED") ("drop" ("true" "false") "false")))) (req-n 2) (dfa (quote (finite-state-automaton 0 (2) #((0 b 1) (1 c 2)) #((leno-elements  . b) (terminator$$  . c)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "splice-page-without"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "splice-page-without")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "splice-page-without"))))

(define (leno-elements-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0) (dfa (quote (finite-state-automaton 0 (2) #((0 b 1) (0 c 2) (1 b 1) (1 c 2)) #((element-name  . b) (terminator$$  . c)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "leno-elements"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "leno-elements")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "leno-elements"))))

(define (element-name-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0)) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "element-name"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "element-name")) (if xml-validate-contents? (validate-as-pcdata! contents "element-name"))))

(define (side-track-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("drop" ("true" "false") "false") ("track-lecture-id" "CDATA" "#IMPLIED") ("track-url" "CDATA" "#IMPLIED") ("annotations" ("unfold-before" "unfold-after" "keep" "merge" "ignore") "unfold-after")))) (req-n 0) (dfa (quote (finite-state-automaton 0 (3) #((0 b 1) (1 c 2) (1 d 3) (2 d 3)) #((annotation  . c) (main-text  . b) (terminator$$  . d)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "side-track"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "side-track")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "side-track"))))

(define (quiz-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0) (dfa (quote (finite-state-automaton 0 (3) #((0 b 1) (1 c 2) (2 d 3)) #((answers  . c) (question  . b) (terminator$$  . d)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "quiz"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "quiz")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "quiz"))))

(define (question-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0)) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "question"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "question")) (if xml-validate-contents? (validate-as-pcdata! contents "question"))))

(define (answers-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0) (dfa (quote (finite-state-automaton 0 (2) #((0 b 1) (0 c 2) (1 b 1) (1 c 2)) #((answer  . b) (terminator$$  . c)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "answers"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "answers")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "answers"))))

(define (answer-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("correctness" "CDATA" "#REQUIRED")))) (req-n 1) (dfa (quote (finite-state-automaton 0 (3) #((0 b 1) (1 c 2) (2 d 3)) #((answer-clarification  . c) (answer-possibility  . b) (terminator$$  . d)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "answer"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "answer")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "answer"))))

(define (answer-possibility-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0)) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "answer-possibility"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "answer-possibility")) (if xml-validate-contents? (validate-as-pcdata! contents "answer-possibility"))))

(define (answer-clarification-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0)) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "answer-clarification"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "answer-clarification")) (if xml-validate-contents? (validate-as-pcdata! contents "answer-clarification"))))

(define (applet-program-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("code" "CDATA" "#REQUIRED") ("code-base" "CDATA" "#REQUIRED") ("height" "CDATA" "#REQUIRED") ("width" "CDATA" "#REQUIRED") ("id" "ID" "#IMPLIED") ("margin" "CDATA" "#IMPLIED") ("margin-left" "CDATA" "#IMPLIED") ("margin-right" "CDATA" "#IMPLIED") ("margin-bottom" "CDATA" "#IMPLIED") ("margin-top" "CDATA" "#IMPLIED") ("drop" ("true" "false") "false")))) (req-n 4) (dfa (quote (finite-state-automaton 0 (3) #((0 b 1) (1 c 2) (1 d 3) (2 c 2) (2 d 3)) #((applet-param  . c) (main-text  . b) (terminator$$  . d)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "applet-program"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "applet-program")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "applet-program"))))

(define (applet-param-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("name" "CDATA" "#REQUIRED") ("value" "CDATA" "#REQUIRED")))) (req-n 2)) (xml-check-for-empty-contents! contents "applet-param") (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "applet-param"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "applet-param"))))

(define (quotation-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("id" "ID" "#IMPLIED") ("margin" "CDATA" "#IMPLIED") ("margin-left" "CDATA" "#IMPLIED") ("margin-right" "CDATA" "#IMPLIED") ("margin-bottom" "CDATA" "#IMPLIED") ("margin-top" "CDATA" "#IMPLIED") ("drop" ("true" "false") "false") ("annotations" ("unfold-before" "unfold-after" "keep" "merge" "ignore") "unfold-after")))) (req-n 0) (dfa (quote (finite-state-automaton 0 (3) #((0 b 1) (1 c 2) (1 d 3) (2 d 3)) #((annotation  . c) (main-text  . b) (terminator$$  . d)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "quotation"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "quotation")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "quotation"))))

(define (synopsis-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("id" "ID" "#IMPLIED") ("margin" "CDATA" "#IMPLIED") ("margin-left" "CDATA" "#IMPLIED") ("margin-right" "CDATA" "#IMPLIED") ("margin-bottom" "CDATA" "#IMPLIED") ("margin-top" "CDATA" "#IMPLIED") ("drop" ("true" "false") "false")))) (req-n 0) (dfa (quote (finite-state-automaton 0 (2) #((0 b 1) (0 c 2) (1 b 1) (1 c 2)) #((synopsis-item  . b) (terminator$$  . c)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "synopsis"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "synopsis")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "synopsis"))))

(define (synopsis-item-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("id" "ID" "#IMPLIED") ("annotations" ("unfold-before" "unfold-after" "keep" "merge" "ignore") "unfold-after")))) (req-n 0) (dfa (quote (finite-state-automaton 0 (3) #((0 b 1) (1 c 2) (1 d 3) (2 d 3)) #((annotation  . c) (main-text  . b) (terminator$$  . d)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "synopsis-item"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "synopsis-item")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "synopsis-item"))))

(define (slide-space-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("amount" "CDATA" "#IMPLIED")))) (req-n 0)) (xml-check-for-empty-contents! contents "slide-space") (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "slide-space"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "slide-space"))))

(define (svg-image-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("id" "CDATA" "#REQUIRED") ("width" "CDATA" "#REQUIRED") ("height" "CDATA" "#REQUIRED") ("margin" "CDATA" "#IMPLIED") ("margin-left" "CDATA" "#IMPLIED") ("margin-right" "CDATA" "#IMPLIED") ("margin-bottom" "CDATA" "#IMPLIED") ("margin-top" "CDATA" "#IMPLIED") ("drop" ("true" "false") "false") ("src" "CDATA" "#IMPLIED")))) (req-n 3) (dfa (quote (finite-state-automaton 0 (3) #((0 b 1) (1 c 2) (1 d 3) (2 d 3)) #((main-text  . b) (svg-inline  . c) (terminator$$  . d)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "svg-image"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "svg-image")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "svg-image"))))

(define (svg-inline-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote ())) (req-n 0) (dfa (quote (finite-state-automaton 0 (3) #((0 b 1) (0 c 2) (1 d 3) (2 d 3)) #((g  . b) (svg  . c) (terminator$$  . d)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "svg-inline"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "svg-inline")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "svg-inline"))))

(define (flash-image-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("width" "CDATA" "#REQUIRED") ("height" "CDATA" "#REQUIRED") ("src" "CDATA" "#REQUIRED") ("id" "ID" "#IMPLIED") ("margin" "CDATA" "#IMPLIED") ("margin-left" "CDATA" "#IMPLIED") ("margin-right" "CDATA" "#IMPLIED") ("margin-bottom" "CDATA" "#IMPLIED") ("margin-top" "CDATA" "#IMPLIED") ("drop" ("true" "false") "false")))) (req-n 3) (dfa (quote (finite-state-automaton 0 (2) #((0 b 1) (1 c 2)) #((main-text  . b) (terminator$$  . c)))))) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "flash-image"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "flash-image")) (if xml-validate-contents? (validate-contents-by-dfa! contents dfa "flash-image"))))

(define (meta-text-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("type" ("readers-guide" "normal") "normal") ("id" "CDATA" "#IMPLIED") ("drop" ("true" "false") "false")))) (req-n 0)) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "meta-text"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "meta-text")) (if xml-validate-contents? (validate-as-pcdata! contents "meta-text"))))

(define (theme-text-leno1-laml-validate! el-name attributes contents overlap-check?) (let ((attributes-of-elements (quote (("id" "CDATA" "#IMPLIED") ("drop" ("true" "false") "false")))) (req-n 0)) (if (and overlap-check? xml-check-language-overlap?) (check-language-overlap! (as-symbol "theme-text"))) (if xml-check-attributes? (xml-check-attributes! attributes attributes-of-elements req-n "theme-text")) (if xml-validate-contents? (validate-as-pcdata! contents "theme-text"))))

;;; Make and put XML mirror functions in the temporary language map:
(set! temp-mirror-function (generate-xml-mirror-function leno-leno1-laml-validate! "leno" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "leno" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function leno-leno1-laml-validate! "leno" (quote ()) (quote double) (quote leno1) #t #f))
(define leno temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function leno-front-matters-leno1-laml-validate! "leno-front-matters" (quote (slide-view "true" annotated-slide-view "true" aggregated-view "true" theme-view "false" primary-view "slide-view" trail-of-lecture "false" language "english" show-and-speak "false" show-and-speak-author-mode "false" exercise-model "make-indexes-and-solutions-per-lecture" mouse-advancement "double-press" word-index "true" word-index-type "slide" css-stylesheet-copying "true" news-flash-level "1" verbosity-level "1" process-all-lectures "false" clean-html-directory "false" theme-source "none" theme-auto-process "false" make-print-page "false" trail-source "none" source-destination-delta "html/" html-pdf-delta "../pdf/" source-program-index "true" source-index-page "true" treat-svg-images-as "svg" presentation-medium "web" use-doc-comments "false" use-note-page-importance "false")) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "leno-front-matters" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function leno-front-matters-leno1-laml-validate! "leno-front-matters" (quote (slide-view "true" annotated-slide-view "true" aggregated-view "true" theme-view "false" primary-view "slide-view" trail-of-lecture "false" language "english" show-and-speak "false" show-and-speak-author-mode "false" exercise-model "make-indexes-and-solutions-per-lecture" mouse-advancement "double-press" word-index "true" word-index-type "slide" css-stylesheet-copying "true" news-flash-level "1" verbosity-level "1" process-all-lectures "false" clean-html-directory "false" theme-source "none" theme-auto-process "false" make-print-page "false" trail-source "none" source-destination-delta "html/" html-pdf-delta "../pdf/" source-program-index "true" source-index-page "true" treat-svg-images-as "svg" presentation-medium "web" use-doc-comments "false" use-note-page-importance "false")) (quote double) (quote leno1) #t #t))
(define leno-front-matters temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function front-title-leno1-laml-validate! "front-title" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "front-title" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function front-title-leno1-laml-validate! "front-title" (quote ()) (quote double) (quote leno1) #t #f))
(define front-title temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function front-subtitle-leno1-laml-validate! "front-subtitle" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "front-subtitle" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function front-subtitle-leno1-laml-validate! "front-subtitle" (quote ()) (quote double) (quote leno1) #t #f))
(define front-subtitle temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function front-author-leno1-laml-validate! "front-author" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "front-author" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function front-author-leno1-laml-validate! "front-author" (quote ()) (quote double) (quote leno1) #t #f))
(define front-author temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function front-affiliation-leno1-laml-validate! "front-affiliation" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "front-affiliation" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function front-affiliation-leno1-laml-validate! "front-affiliation" (quote ()) (quote double) (quote leno1) #t #f))
(define front-affiliation temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function front-abstract-leno1-laml-validate! "front-abstract" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "front-abstract" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function front-abstract-leno1-laml-validate! "front-abstract" (quote ()) (quote double) (quote leno1) #t #f))
(define front-abstract temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function begin-notes-leno1-laml-validate! "begin-notes" (quote ()) (quote single) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "begin-notes" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function begin-notes-leno1-laml-validate! "begin-notes" (quote ()) (quote single) (quote leno1) #t #t))
(define begin-notes temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function end-notes-leno1-laml-validate! "end-notes" (quote ()) (quote single) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "end-notes" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function end-notes-leno1-laml-validate! "end-notes" (quote ()) (quote single) (quote leno1) #t #t))
(define end-notes temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function note-page-leno1-laml-validate! "note-page" (quote (drop "false")) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "note-page" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function note-page-leno1-laml-validate! "note-page" (quote (drop "false")) (quote double) (quote leno1) #t #t))
(define note-page temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function title-leno1-laml-validate! "title" (quote (drop "false" annotations "unfold-after")) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "title" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function title-leno1-laml-validate! "title" (quote (drop "false" annotations "unfold-after")) (quote double) (quote leno1) #t #f))
(define title temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function main-text-leno1-laml-validate! "main-text" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "main-text" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function main-text-leno1-laml-validate! "main-text" (quote ()) (quote double) (quote leno1) #t #f))
(define main-text temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function annotation-leno1-laml-validate! "annotation" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "annotation" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function annotation-leno1-laml-validate! "annotation" (quote ()) (quote double) (quote leno1) #t #f))
(define annotation temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function section-title-leno1-laml-validate! "section-title" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "section-title" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function section-title-leno1-laml-validate! "section-title" (quote ()) (quote double) (quote leno1) #t #f))
(define section-title temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function point-leno1-laml-validate! "point" (quote (drop "false" annotations "unfold-after")) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "point" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function point-leno1-laml-validate! "point" (quote (drop "false" annotations "unfold-after")) (quote double) (quote leno1) #t #f))
(define point temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function items-leno1-laml-validate! "items" (quote (drop "false" annotations "unfold-after")) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "items" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function items-leno1-laml-validate! "items" (quote (drop "false" annotations "unfold-after")) (quote double) (quote leno1) #t #f))
(define items temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function item-leno1-laml-validate! "item" (quote (drop "false" annotations "unfold-after")) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "item" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function item-leno1-laml-validate! "item" (quote (drop "false" annotations "unfold-after")) (quote double) (quote leno1) #t #f))
(define item temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function source-program-leno1-laml-validate! "source-program" (quote (drop "false" slide-mode "inline" book-mode "inline" indexed "true" kind "source-program" program-annotations "true")) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "source-program" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function source-program-leno1-laml-validate! "source-program" (quote (drop "false" slide-mode "inline" book-mode "inline" indexed "true" kind "source-program" program-annotations "true")) (quote double) (quote leno1) #t #f))
(define source-program temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function color-decorations-leno1-laml-validate! "color-decorations" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "color-decorations" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function color-decorations-leno1-laml-validate! "color-decorations" (quote ()) (quote double) (quote leno1) #t #f))
(define color-decorations temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function color-decoration-leno1-laml-validate! "color-decoration" (quote ()) (quote single) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "color-decoration" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function color-decoration-leno1-laml-validate! "color-decoration" (quote ()) (quote single) (quote leno1) #t #f))
(define color-decoration temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function image-leno1-laml-validate! "image" (quote (drop "false")) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "image" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function image-leno1-laml-validate! "image" (quote (drop "false")) (quote double) (quote leno1) #t #f))
(define image temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function concept-list-leno1-laml-validate! "concept-list" (quote (drop "false")) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "concept-list" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function concept-list-leno1-laml-validate! "concept-list" (quote (drop "false")) (quote double) (quote leno1) #t #f))
(define concept-list temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function concept-leno1-laml-validate! "concept" (quote (annotations "unfold-after")) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "concept" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function concept-leno1-laml-validate! "concept" (quote (annotations "unfold-after")) (quote double) (quote leno1) #t #f))
(define concept temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function example-leno1-laml-validate! "example" (quote (drop "false" annotations "unfold-after")) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "example" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function example-leno1-laml-validate! "example" (quote (drop "false" annotations "unfold-after")) (quote double) (quote leno1) #t #f))
(define example temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function opposing-leno1-laml-validate! "opposing" (quote (drop "false")) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "opposing" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function opposing-leno1-laml-validate! "opposing" (quote (drop "false")) (quote double) (quote leno1) #t #f))
(define opposing temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function opposing-item-leno1-laml-validate! "opposing-item" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "opposing-item" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function opposing-item-leno1-laml-validate! "opposing-item" (quote ()) (quote double) (quote leno1) #t #f))
(define opposing-item temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function left-item-leno1-laml-validate! "left-item" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "left-item" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function left-item-leno1-laml-validate! "left-item" (quote ()) (quote double) (quote leno1) #t #f))
(define left-item temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function right-item-leno1-laml-validate! "right-item" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "right-item" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function right-item-leno1-laml-validate! "right-item" (quote ()) (quote double) (quote leno1) #t #f))
(define right-item temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function comment-leno1-laml-validate! "comment" (quote (drop "false")) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "comment" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function comment-leno1-laml-validate! "comment" (quote (drop "false")) (quote double) (quote leno1) #t #f))
(define comment temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function language-syntax-leno1-laml-validate! "language-syntax" (quote (drop "false" annotations "unfold-after")) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "language-syntax" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function language-syntax-leno1-laml-validate! "language-syntax" (quote (drop "false" annotations "unfold-after")) (quote double) (quote leno1) #t #f))
(define language-syntax temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function tabular-leno1-laml-validate! "tabular" (quote (drop "false" annotations "unfold-after")) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "tabular" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function tabular-leno1-laml-validate! "tabular" (quote (drop "false" annotations "unfold-after")) (quote double) (quote leno1) #t #f))
(define tabular temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function row-widths-leno1-laml-validate! "row-widths" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "row-widths" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function row-widths-leno1-laml-validate! "row-widths" (quote ()) (quote double) (quote leno1) #t #f))
(define row-widths temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function row-leno1-laml-validate! "row" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "row" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function row-leno1-laml-validate! "row" (quote ()) (quote double) (quote leno1) #t #f))
(define row temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function cell-leno1-laml-validate! "cell" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "cell" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function cell-leno1-laml-validate! "cell" (quote ()) (quote double) (quote leno1) #t #f))
(define cell temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function text-leno1-laml-validate! "text" (quote (drop "false" annotations "unfold-after")) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "text" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function text-leno1-laml-validate! "text" (quote (drop "false" annotations "unfold-after")) (quote double) (quote leno1) #t #f))
(define text temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function note-text-leno1-laml-validate! "note-text" (quote (drop "false")) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "note-text" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function note-text-leno1-laml-validate! "note-text" (quote (drop "false")) (quote double) (quote leno1) #t #f))
(define note-text temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function slide-text-leno1-laml-validate! "slide-text" (quote (drop "false")) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "slide-text" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function slide-text-leno1-laml-validate! "slide-text" (quote (drop "false")) (quote double) (quote leno1) #t #f))
(define slide-text temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function cross-references-leno1-laml-validate! "cross-references" (quote (drop "false")) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "cross-references" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function cross-references-leno1-laml-validate! "cross-references" (quote (drop "false")) (quote double) (quote leno1) #t #f))
(define cross-references temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function internet-reference-leno1-laml-validate! "internet-reference" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "internet-reference" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function internet-reference-leno1-laml-validate! "internet-reference" (quote ()) (quote double) (quote leno1) #t #f))
(define internet-reference temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function note-reference-leno1-laml-validate! "note-reference" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "note-reference" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function note-reference-leno1-laml-validate! "note-reference" (quote ()) (quote double) (quote leno1) #t #f))
(define note-reference temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function informal-reference-leno1-laml-validate! "informal-reference" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "informal-reference" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function informal-reference-leno1-laml-validate! "informal-reference" (quote ()) (quote double) (quote leno1) #t #f))
(define informal-reference temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function bibtex-reference-leno1-laml-validate! "bibtex-reference" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "bibtex-reference" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function bibtex-reference-leno1-laml-validate! "bibtex-reference" (quote ()) (quote double) (quote leno1) #t #f))
(define bibtex-reference temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function location-hints-leno1-laml-validate! "location-hints" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "location-hints" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function location-hints-leno1-laml-validate! "location-hints" (quote ()) (quote double) (quote leno1) #t #f))
(define location-hints temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function hint-leno1-laml-validate! "hint" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "hint" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function hint-leno1-laml-validate! "hint" (quote ()) (quote double) (quote leno1) #t #f))
(define hint temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function exercise-leno1-laml-validate! "exercise" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "exercise" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function exercise-leno1-laml-validate! "exercise" (quote ()) (quote double) (quote leno1) #t #f))
(define exercise temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function formulation-leno1-laml-validate! "formulation" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "formulation" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function formulation-leno1-laml-validate! "formulation" (quote ()) (quote double) (quote leno1) #t #f))
(define formulation temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function solution-leno1-laml-validate! "solution" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "solution" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function solution-leno1-laml-validate! "solution" (quote ()) (quote double) (quote leno1) #t #f))
(define solution temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function index-words-leno1-laml-validate! "index-words" (quote (drop "false")) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "index-words" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function index-words-leno1-laml-validate! "index-words" (quote (drop "false")) (quote double) (quote leno1) #t #f))
(define index-words temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function index-word-leno1-laml-validate! "index-word" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "index-word" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function index-word-leno1-laml-validate! "index-word" (quote ()) (quote double) (quote leno1) #t #f))
(define index-word temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function image-series-leno1-laml-validate! "image-series" (quote (drop "false")) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "image-series" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function image-series-leno1-laml-validate! "image-series" (quote (drop "false")) (quote double) (quote leno1) #t #f))
(define image-series temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function image-series-item-leno1-laml-validate! "image-series-item" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "image-series-item" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function image-series-item-leno1-laml-validate! "image-series-item" (quote ()) (quote double) (quote leno1) #t #f))
(define image-series-item temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function slide-image-leno1-laml-validate! "slide-image" (quote (drop "false")) (quote single) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "slide-image" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function slide-image-leno1-laml-validate! "slide-image" (quote (drop "false")) (quote single) (quote leno1) #t #f))
(define slide-image temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function show-and-speak-leno1-laml-validate! "show-and-speak" (quote (drop "false")) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "show-and-speak" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function show-and-speak-leno1-laml-validate! "show-and-speak" (quote (drop "false")) (quote double) (quote leno1) #t #f))
(define show-and-speak temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function slide-part-leno1-laml-validate! "slide-part" (quote ()) (quote single) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "slide-part" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function slide-part-leno1-laml-validate! "slide-part" (quote ()) (quote single) (quote leno1) #t #f))
(define slide-part temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function program-part-leno1-laml-validate! "program-part" (quote ()) (quote single) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "program-part" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function program-part-leno1-laml-validate! "program-part" (quote ()) (quote single) (quote leno1) #t #f))
(define program-part temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function image-series-part-leno1-laml-validate! "image-series-part" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "image-series-part" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function image-series-part-leno1-laml-validate! "image-series-part" (quote ()) (quote double) (quote leno1) #t #f))
(define image-series-part temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function image-part-leno1-laml-validate! "image-part" (quote ()) (quote single) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "image-part" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function image-part-leno1-laml-validate! "image-part" (quote ()) (quote single) (quote leno1) #t #f))
(define image-part temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function lecturer-photos-leno1-laml-validate! "lecturer-photos" (quote (drop "false")) (quote single) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "lecturer-photos" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function lecturer-photos-leno1-laml-validate! "lecturer-photos" (quote (drop "false")) (quote single) (quote leno1) #t #f))
(define lecturer-photos temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function lecturer-photos-and-logo-leno1-laml-validate! "lecturer-photos-and-logo" (quote (drop "false")) (quote single) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "lecturer-photos-and-logo" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function lecturer-photos-and-logo-leno1-laml-validate! "lecturer-photos-and-logo" (quote (drop "false")) (quote single) (quote leno1) #t #f))
(define lecturer-photos-and-logo temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function elucidate-leno1-laml-validate! "elucidate" (quote (drop "false")) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "elucidate" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function elucidate-leno1-laml-validate! "elucidate" (quote (drop "false")) (quote double) (quote leno1) #t #f))
(define elucidate temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function splice-page-with-leno1-laml-validate! "splice-page-with" (quote (drop "false")) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "splice-page-with" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function splice-page-with-leno1-laml-validate! "splice-page-with" (quote (drop "false")) (quote double) (quote leno1) #t #f))
(define splice-page-with temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function splice-page-without-leno1-laml-validate! "splice-page-without" (quote (drop "false")) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "splice-page-without" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function splice-page-without-leno1-laml-validate! "splice-page-without" (quote (drop "false")) (quote double) (quote leno1) #t #f))
(define splice-page-without temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function leno-elements-leno1-laml-validate! "leno-elements" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "leno-elements" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function leno-elements-leno1-laml-validate! "leno-elements" (quote ()) (quote double) (quote leno1) #t #f))
(define leno-elements temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function element-name-leno1-laml-validate! "element-name" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "element-name" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function element-name-leno1-laml-validate! "element-name" (quote ()) (quote double) (quote leno1) #t #f))
(define element-name temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function side-track-leno1-laml-validate! "side-track" (quote (drop "false" annotations "unfold-after")) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "side-track" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function side-track-leno1-laml-validate! "side-track" (quote (drop "false" annotations "unfold-after")) (quote double) (quote leno1) #t #f))
(define side-track temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function quiz-leno1-laml-validate! "quiz" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "quiz" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function quiz-leno1-laml-validate! "quiz" (quote ()) (quote double) (quote leno1) #t #f))
(define quiz temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function question-leno1-laml-validate! "question" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "question" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function question-leno1-laml-validate! "question" (quote ()) (quote double) (quote leno1) #t #f))
(define question temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function answers-leno1-laml-validate! "answers" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "answers" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function answers-leno1-laml-validate! "answers" (quote ()) (quote double) (quote leno1) #t #f))
(define answers temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function answer-leno1-laml-validate! "answer" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "answer" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function answer-leno1-laml-validate! "answer" (quote ()) (quote double) (quote leno1) #t #f))
(define answer temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function answer-possibility-leno1-laml-validate! "answer-possibility" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "answer-possibility" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function answer-possibility-leno1-laml-validate! "answer-possibility" (quote ()) (quote double) (quote leno1) #t #f))
(define answer-possibility temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function answer-clarification-leno1-laml-validate! "answer-clarification" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "answer-clarification" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function answer-clarification-leno1-laml-validate! "answer-clarification" (quote ()) (quote double) (quote leno1) #t #f))
(define answer-clarification temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function applet-program-leno1-laml-validate! "applet-program" (quote (drop "false")) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "applet-program" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function applet-program-leno1-laml-validate! "applet-program" (quote (drop "false")) (quote double) (quote leno1) #t #f))
(define applet-program temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function applet-param-leno1-laml-validate! "applet-param" (quote ()) (quote single) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "applet-param" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function applet-param-leno1-laml-validate! "applet-param" (quote ()) (quote single) (quote leno1) #t #f))
(define applet-param temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function quotation-leno1-laml-validate! "quotation" (quote (drop "false" annotations "unfold-after")) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "quotation" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function quotation-leno1-laml-validate! "quotation" (quote (drop "false" annotations "unfold-after")) (quote double) (quote leno1) #t #f))
(define quotation temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function synopsis-leno1-laml-validate! "synopsis" (quote (drop "false")) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "synopsis" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function synopsis-leno1-laml-validate! "synopsis" (quote (drop "false")) (quote double) (quote leno1) #t #f))
(define synopsis temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function synopsis-item-leno1-laml-validate! "synopsis-item" (quote (annotations "unfold-after")) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "synopsis-item" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function synopsis-item-leno1-laml-validate! "synopsis-item" (quote (annotations "unfold-after")) (quote double) (quote leno1) #t #f))
(define synopsis-item temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function slide-space-leno1-laml-validate! "slide-space" (quote ()) (quote single) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "slide-space" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function slide-space-leno1-laml-validate! "slide-space" (quote ()) (quote single) (quote leno1) #t #f))
(define slide-space temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function svg-image-leno1-laml-validate! "svg-image" (quote (drop "false")) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "svg-image" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function svg-image-leno1-laml-validate! "svg-image" (quote (drop "false")) (quote double) (quote leno1) #t #f))
(define svg-image temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function svg-inline-leno1-laml-validate! "svg-inline" (quote ()) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "svg-inline" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function svg-inline-leno1-laml-validate! "svg-inline" (quote ()) (quote double) (quote leno1) #t #f))
(define svg-inline temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function flash-image-leno1-laml-validate! "flash-image" (quote (drop "false")) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "flash-image" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function flash-image-leno1-laml-validate! "flash-image" (quote (drop "false")) (quote double) (quote leno1) #t #f))
(define flash-image temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function meta-text-leno1-laml-validate! "meta-text" (quote (type "normal" drop "false")) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "meta-text" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function meta-text-leno1-laml-validate! "meta-text" (quote (type "normal" drop "false")) (quote double) (quote leno1) #t #f))
(define meta-text temp-mirror-function)

(set! temp-mirror-function (generate-xml-mirror-function theme-text-leno1-laml-validate! "theme-text" (quote (drop "false")) (quote double) (quote leno1) #f #f))
(set! temp-language-map (put-mirror-function temp-language-map "theme-text" temp-mirror-function))
(set! temp-mirror-function (generate-xml-mirror-function theme-text-leno1-laml-validate! "theme-text" (quote (drop "false")) (quote double) (quote leno1) #t #f))
(define theme-text temp-mirror-function)

; Register the name of the language:
(register-xml-in-laml-language (quote leno1) temp-language-map)

; Define the language variable
(define leno1 (activator-via-language-map (quote leno1)))

; Register the XML navigator of the language:
(register-xml-in-laml-navigator (quote leno1) (quote (xml-navigator #((annotation #(annotation) #()) (answer #(answer answer-clarification answer-possibility) #(correctness)) (answer-clarification #(answer-clarification) #()) (answer-possibility #(answer-possibility) #()) (answers #(answer answer-clarification answer-possibility answers) #(correctness)) (applet-param #(applet-param) #(name value)) (applet-program #(applet-param applet-program main-text) #(code code-base drop height id margin margin-bottom margin-left margin-right margin-top name value width)) (begin-notes #(begin-notes) #()) (bibtex-reference #(bibtex-reference hint location-hints) #(key)) (cell #(cell) #()) (color-decoration #(color-decoration) #(color face from-mark repetition to-mark)) (color-decorations #(color-decoration color-decorations) #(color face from-mark repetition to-mark)) (comment #(comment) #(drop)) (concept #(annotation concept main-text) #(annotations concept-name id)) (concept-list #(annotation concept concept-list main-text) #(annotations concept-name drop id margin margin-bottom margin-left margin-right margin-top)) (cross-references #(bibtex-reference cross-references hint informal-reference internet-reference location-hints main-text note-reference) #(drop href id key lecture-id margin margin-bottom margin-left margin-right margin-top page-id target title)) (element-name #(element-name) #()) (elucidate #(elucidate) #(drop href id margin margin-bottom margin-left margin-right margin-top target)) (end-notes #(end-notes) #()) (example #(annotation example main-text) #(annotations drop id margin margin-bottom margin-left margin-right margin-top)) (exercise #(exercise formulation solution) #(id rank title)) (flash-image #(flash-image main-text) #(drop height id margin margin-bottom margin-left margin-right margin-top src width)) (formulation #(formulation) #()) (front-abstract #(front-abstract) #()) (front-affiliation #(front-affiliation) #()) (front-author #(front-author) #()) (front-subtitle #(front-subtitle) #()) (front-title #(front-title) #()) (hint #(hint) #()) (image #(image main-text) #(alignment drop first id margin margin-bottom margin-left margin-right margin-top second src)) (image-part #(image-part) #(seconds)) (image-series #(image-series image-series-item) #(book-mode drop id margin margin-bottom margin-left margin-right margin-top slide-mode src title)) (image-series-item #(image-series-item) #(src)) (image-series-part #(image-part image-series-part) #(number seconds)) (index-word #(index-word) #()) (index-words #(index-word index-words) #(drop)) (informal-reference #(hint informal-reference location-hints main-text) #(id title)) (internet-reference #(hint internet-reference location-hints main-text) #(href id target)) (item #(annotation item items main-text) #(annotations drop id margin margin-bottom margin-left margin-right margin-top)) (items #(annotation item items main-text) #(annotations drop id margin margin-bottom margin-left margin-right margin-top)) (language-syntax #(annotation language-syntax main-text) #(annotations drop id margin margin-bottom margin-left margin-right margin-top)) (lecturer-photos #(lecturer-photos) #(drop id margin margin-bottom margin-left margin-right margin-top number-of-photos start-number)) (lecturer-photos-and-logo #(lecturer-photos-and-logo) #(drop id margin margin-bottom margin-left margin-right margin-top start-number)) (left-item #(left-item) #()) (leno #(annotation answer answer-clarification answer-possibility answers applet-param applet-program begin-notes bibtex-reference cell color-decoration color-decorations comment concept concept-list cross-references element-name elucidate end-notes example exercise flash-image formulation front-abstract front-affiliation front-author front-subtitle front-title g hint image image-part image-series image-series-item image-series-part index-word index-words informal-reference internet-reference item items language-syntax lecturer-photos lecturer-photos-and-logo left-item leno leno-elements leno-front-matters location-hints main-text meta-text note-page note-reference note-text opposing opposing-item point program-part question quiz quotation right-item row row-widths section-title show-and-speak side-track slide-image slide-part slide-space slide-text solution source-program splice-page-with splice-page-without svg svg-image svg-inline synopsis synopsis-item tabular text theme-text title) #(additional-showing-time aggregated-view alignment amount annotated-slide-view annotations author-home-url background-color book-mode border clean-html-directory code code-base color concept-name correctness course-home-url css-prestylesheet css-stylesheet css-stylesheet-copying default-showing-time doc-comment-prefix drop element-id exercise-model face first from-mark height href html-pdf-delta id importance index-title indexed key kind language lecture-id lecture-type logo-url make-print-page margin margin-bottom margin-left margin-right margin-top mouse-advancement name news-flash-level news-flash-string news-flash-url note-contents-description note-download-url number number-of-photos page-id pdf-version-as-of presentation-medium primary-view process-all-lectures program-annotations quiz-support rank repetition scheme-prefix scheme-suffix second seconds show-and-speak show-and-speak-author-mode slide-header slide-mode slide-view sound-source source-destination-delta source-index-page source-program-index speak-file-prefix speak-url-prefix src start-number target theme-auto-process theme-source theme-view title to-mark track-lecture-id track-url trail-of-lecture trail-source treat-svg-images-as type use-doc-comments use-note-page-importance value verbosity-level width word-index word-index-type)) (leno-elements #(element-name leno-elements) #()) (leno-front-matters #(front-abstract front-affiliation front-author front-subtitle front-title leno-front-matters) #(additional-showing-time aggregated-view annotated-slide-view author-home-url clean-html-directory course-home-url css-prestylesheet css-stylesheet css-stylesheet-copying default-showing-time doc-comment-prefix exercise-model html-pdf-delta language lecture-type logo-url make-print-page mouse-advancement news-flash-level news-flash-string news-flash-url note-contents-description note-download-url pdf-version-as-of presentation-medium primary-view process-all-lectures quiz-support scheme-prefix scheme-suffix show-and-speak show-and-speak-author-mode slide-header slide-view sound-source source-destination-delta source-index-page source-program-index speak-file-prefix speak-url-prefix theme-auto-process theme-source theme-view trail-of-lecture trail-source treat-svg-images-as use-doc-comments use-note-page-importance verbosity-level word-index word-index-type)) (location-hints #(hint location-hints) #()) (main-text #(main-text) #()) (meta-text #(meta-text) #(drop id type)) (note-page #(annotation answer answer-clarification answer-possibility answers applet-param applet-program bibtex-reference cell color-decoration color-decorations comment concept concept-list cross-references element-name elucidate example exercise flash-image formulation g hint image image-part image-series image-series-item image-series-part index-word index-words informal-reference internet-reference item items language-syntax lecturer-photos lecturer-photos-and-logo left-item leno-elements location-hints main-text meta-text note-page note-reference note-text opposing opposing-item point program-part question quiz quotation right-item row row-widths section-title show-and-speak side-track slide-image slide-part slide-space slide-text solution source-program splice-page-with splice-page-without svg svg-image svg-inline synopsis synopsis-item tabular text theme-text title) #(alignment amount annotations background-color book-mode border code code-base color concept-name correctness drop element-id face first from-mark height href id importance index-title indexed key kind lecture-id margin margin-bottom margin-left margin-right margin-top name number number-of-photos page-id program-annotations rank repetition second seconds slide-mode src start-number target title to-mark track-lecture-id track-url type value width)) (note-reference #(hint location-hints main-text note-reference) #(id lecture-id page-id)) (note-text #(note-text) #(drop id margin margin-bottom margin-left margin-right margin-top)) (opposing #(left-item opposing opposing-item right-item) #(drop id margin margin-bottom margin-left margin-right margin-top)) (opposing-item #(left-item opposing-item right-item) #()) (point #(annotation main-text point) #(annotations drop id margin margin-bottom margin-left margin-right margin-top)) (program-part #(program-part) #(number seconds)) (question #(question) #()) (quiz #(answer answer-clarification answer-possibility answers question quiz) #(correctness)) (quotation #(annotation main-text quotation) #(annotations drop id margin margin-bottom margin-left margin-right margin-top)) (right-item #(right-item) #()) (row #(cell row) #()) (row-widths #(cell row-widths) #()) (section-title #(section-title) #(id)) (show-and-speak #(image-part image-series-part program-part show-and-speak slide-part) #(drop number seconds)) (side-track #(annotation main-text side-track) #(annotations drop track-lecture-id track-url)) (slide-image #(slide-image) #(drop id margin margin-bottom margin-left margin-right margin-top src)) (slide-part #(slide-part) #(number seconds)) (slide-space #(slide-space) #(amount)) (slide-text #(slide-text) #(drop id margin margin-bottom margin-left margin-right margin-top)) (solution #(solution) #()) (source-program #(annotation color-decoration color-decorations main-text source-program) #(background-color book-mode color drop face from-mark id index-title indexed kind margin margin-bottom margin-left margin-right margin-top program-annotations repetition slide-mode src to-mark)) (splice-page-with #(element-name leno-elements splice-page-with) #(drop element-id lecture-id page-id)) (splice-page-without #(element-name leno-elements splice-page-without) #(drop lecture-id page-id)) (svg-image #(g main-text svg svg-image svg-inline) #(drop height id margin margin-bottom margin-left margin-right margin-top src width)) (svg-inline #(g svg svg-inline) #()) (synopsis #(annotation main-text synopsis synopsis-item) #(annotations drop id margin margin-bottom margin-left margin-right margin-top)) (synopsis-item #(annotation main-text synopsis-item) #(annotations id)) (tabular #(annotation cell row row-widths tabular) #(annotations border drop id margin margin-bottom margin-left margin-right margin-top)) (text #(annotation main-text text) #(annotations drop id margin margin-bottom margin-left margin-right margin-top)) (theme-text #(theme-text) #(drop id)) (title #(annotation main-text title) #(annotations drop id margin margin-bottom margin-left margin-right margin-top))))))

; Register the validation procedures of the language
(register-xml-in-laml-validators (quote leno1) (vector (list "annotation" annotation-leno1-laml-validate!) (list "answer" answer-leno1-laml-validate!) (list "answer-clarification" answer-clarification-leno1-laml-validate!) (list "answer-possibility" answer-possibility-leno1-laml-validate!) (list "answers" answers-leno1-laml-validate!) (list "applet-param" applet-param-leno1-laml-validate!) (list "applet-program" applet-program-leno1-laml-validate!) (list "begin-notes" begin-notes-leno1-laml-validate!) (list "bibtex-reference" bibtex-reference-leno1-laml-validate!) (list "cell" cell-leno1-laml-validate!) (list "color-decoration" color-decoration-leno1-laml-validate!) (list "color-decorations" color-decorations-leno1-laml-validate!) (list "comment" comment-leno1-laml-validate!) (list "concept" concept-leno1-laml-validate!) (list "concept-list" concept-list-leno1-laml-validate!) (list "cross-references" cross-references-leno1-laml-validate!) (list "element-name" element-name-leno1-laml-validate!) (list "elucidate" elucidate-leno1-laml-validate!) (list "end-notes" end-notes-leno1-laml-validate!) (list "example" example-leno1-laml-validate!) (list "exercise" exercise-leno1-laml-validate!) (list "flash-image" flash-image-leno1-laml-validate!) (list "formulation" formulation-leno1-laml-validate!) (list "front-abstract" front-abstract-leno1-laml-validate!) (list "front-affiliation" front-affiliation-leno1-laml-validate!) (list "front-author" front-author-leno1-laml-validate!) (list "front-subtitle" front-subtitle-leno1-laml-validate!) (list "front-title" front-title-leno1-laml-validate!) (list "hint" hint-leno1-laml-validate!) (list "image" image-leno1-laml-validate!) (list "image-part" image-part-leno1-laml-validate!) (list "image-series" image-series-leno1-laml-validate!) (list "image-series-item" image-series-item-leno1-laml-validate!) (list "image-series-part" image-series-part-leno1-laml-validate!) (list "index-word" index-word-leno1-laml-validate!) (list "index-words" index-words-leno1-laml-validate!) (list "informal-reference" informal-reference-leno1-laml-validate!) (list "internet-reference" internet-reference-leno1-laml-validate!) (list "item" item-leno1-laml-validate!) (list "items" items-leno1-laml-validate!) (list "language-syntax" language-syntax-leno1-laml-validate!) (list "lecturer-photos" lecturer-photos-leno1-laml-validate!) (list "lecturer-photos-and-logo" lecturer-photos-and-logo-leno1-laml-validate!) (list "left-item" left-item-leno1-laml-validate!) (list "leno" leno-leno1-laml-validate!) (list "leno-elements" leno-elements-leno1-laml-validate!) (list "leno-front-matters" leno-front-matters-leno1-laml-validate!) (list "location-hints" location-hints-leno1-laml-validate!) (list "main-text" main-text-leno1-laml-validate!) (list "meta-text" meta-text-leno1-laml-validate!) (list "note-page" note-page-leno1-laml-validate!) (list "note-reference" note-reference-leno1-laml-validate!) (list "note-text" note-text-leno1-laml-validate!) (list "opposing" opposing-leno1-laml-validate!) (list "opposing-item" opposing-item-leno1-laml-validate!) (list "point" point-leno1-laml-validate!) (list "program-part" program-part-leno1-laml-validate!) (list "question" question-leno1-laml-validate!) (list "quiz" quiz-leno1-laml-validate!) (list "quotation" quotation-leno1-laml-validate!) (list "right-item" right-item-leno1-laml-validate!) (list "row" row-leno1-laml-validate!) (list "row-widths" row-widths-leno1-laml-validate!) (list "section-title" section-title-leno1-laml-validate!) (list "show-and-speak" show-and-speak-leno1-laml-validate!) (list "side-track" side-track-leno1-laml-validate!) (list "slide-image" slide-image-leno1-laml-validate!) (list "slide-part" slide-part-leno1-laml-validate!) (list "slide-space" slide-space-leno1-laml-validate!) (list "slide-text" slide-text-leno1-laml-validate!) (list "solution" solution-leno1-laml-validate!) (list "source-program" source-program-leno1-laml-validate!) (list "splice-page-with" splice-page-with-leno1-laml-validate!) (list "splice-page-without" splice-page-without-leno1-laml-validate!) (list "svg-image" svg-image-leno1-laml-validate!) (list "svg-inline" svg-inline-leno1-laml-validate!) (list "synopsis" synopsis-leno1-laml-validate!) (list "synopsis-item" synopsis-item-leno1-laml-validate!) (list "tabular" tabular-leno1-laml-validate!) (list "text" text-leno1-laml-validate!) (list "theme-text" theme-text-leno1-laml-validate!) (list "title" title-leno1-laml-validate!)))

; Register the content model map of the language.
; This makes the content model available for LAML at runtime.
(register-xml-in-laml-content-models (quote leno1) (quote #(("annotation" (mixed-content pcdata)) ("answer" (element-content (seq one (name one answer-possibility) (name one answer-clarification)))) ("answer-clarification" (mixed-content pcdata)) ("answer-possibility" (mixed-content pcdata)) ("answers" (element-content (seq zero-or-more (name one answer)))) ("applet-param" empty) ("applet-program" (element-content (seq one (name one main-text) (name zero-or-more applet-param)))) ("begin-notes" empty) ("bibtex-reference" (element-content (seq one (name optional location-hints)))) ("cell" (mixed-content pcdata)) ("color-decoration" empty) ("color-decorations" (element-content (seq zero-or-more (name one color-decoration)))) ("comment" (mixed-content pcdata)) ("concept" (element-content (seq one (name one main-text) (name optional annotation)))) ("concept-list" (element-content (seq one-or-more (name one concept)))) ("cross-references" (element-content (choice zero-or-more (name one internet-reference) (name one note-reference) (name one informal-reference) (name one bibtex-reference)))) ("element-name" (mixed-content pcdata)) ("elucidate" (mixed-content pcdata)) ("end-notes" empty) ("example" (element-content (seq one (name one main-text) (name optional annotation)))) ("exercise" (element-content (seq one (name one formulation) (name optional solution)))) ("flash-image" (element-content (seq one (name one main-text)))) ("formulation" (mixed-content pcdata)) ("front-abstract" (mixed-content pcdata)) ("front-affiliation" (mixed-content pcdata)) ("front-author" (mixed-content pcdata)) ("front-subtitle" (mixed-content pcdata)) ("front-title" (mixed-content pcdata)) ("hint" (mixed-content pcdata)) ("image" (element-content (seq one (name one main-text)))) ("image-part" empty) ("image-series" (element-content (seq zero-or-more (name one image-series-item)))) ("image-series-item" (mixed-content pcdata)) ("image-series-part" (element-content (seq zero-or-more (name one image-part)))) ("index-word" (mixed-content pcdata)) ("index-words" (element-content (seq zero-or-more (name one index-word)))) ("informal-reference" (element-content (seq one (name one main-text) (name optional location-hints)))) ("internet-reference" (element-content (seq one (name one main-text) (name optional location-hints)))) ("item" (element-content (seq one (name one main-text) (name optional annotation) (name optional items)))) ("items" (element-content (seq zero-or-more (name one item)))) ("language-syntax" (element-content (seq one (name one main-text) (name optional annotation)))) ("lecturer-photos" empty) ("lecturer-photos-and-logo" empty) ("left-item" (mixed-content pcdata)) ("leno" (element-content (seq one (name one leno-front-matters) (name one begin-notes) (name zero-or-more note-page) (name one end-notes)))) ("leno-elements" (element-content (seq zero-or-more (name one element-name)))) ("leno-front-matters" (element-content (seq one (name one front-title) (name optional front-subtitle) (name one front-author) (name one front-affiliation) (name one front-abstract)))) ("location-hints" (element-content (seq one-or-more (name one hint)))) ("main-text" (mixed-content pcdata)) ("meta-text" (mixed-content pcdata)) ("note-page" (element-content (choice one (seq one (name one section-title) (choice zero-or-more (name one show-and-speak) (name one lecturer-photos) (name one lecturer-photos-and-logo) (name one splice-page-with) (name one splice-page-without) (name one comment) (name one index-words) (name one quiz) (name one theme-text))) (seq one (name one title) (choice zero-or-more (name one text) (name one point) (name one items) (name one source-program) (name one image) (name one example) (name one opposing) (name one comment) (name one language-syntax) (name one tabular) (name one note-text) (name one slide-text) (name one cross-references) (name one exercise) (name one index-words) (name one image-series) (name one slide-image) (name one show-and-speak) (name one lecturer-photos) (name one lecturer-photos-and-logo) (name one elucidate) (name one splice-page-with) (name one splice-page-without) (name one side-track) (name one slide-space) (name one quiz) (name one quotation) (name one synopsis) (name one applet-program) (name one concept-list) (name one svg-image) (name one flash-image) (name one theme-text) (name one meta-text)))))) ("note-reference" (element-content (seq one (name one main-text) (name optional location-hints)))) ("note-text" (mixed-content pcdata)) ("opposing" (element-content (seq one-or-more (name one opposing-item)))) ("opposing-item" (element-content (seq one (name one left-item) (name one right-item)))) ("point" (element-content (seq one (name one main-text) (name optional annotation)))) ("program-part" empty) ("question" (mixed-content pcdata)) ("quiz" (element-content (seq one (name one question) (name one answers)))) ("quotation" (element-content (seq one (name one main-text) (name optional annotation)))) ("right-item" (mixed-content pcdata)) ("row" (element-content (seq zero-or-more (name one cell)))) ("row-widths" (element-content (seq zero-or-more (name one cell)))) ("section-title" (mixed-content pcdata)) ("show-and-speak" (element-content (choice zero-or-more (name one slide-part) (name one program-part) (name one image-series-part)))) ("side-track" (element-content (seq one (name one main-text) (name optional annotation)))) ("slide-image" empty) ("slide-part" empty) ("slide-space" empty) ("slide-text" (mixed-content pcdata)) ("solution" (mixed-content pcdata)) ("source-program" (element-content (seq one (name optional color-decorations) (name one main-text) (name optional annotation)))) ("splice-page-with" (element-content (seq one (name one leno-elements)))) ("splice-page-without" (element-content (seq one (name one leno-elements)))) ("svg-image" (element-content (seq one (name one main-text) (name optional svg-inline)))) ("svg-inline" (element-content (choice one (name one g) (name one svg)))) ("synopsis" (element-content (seq zero-or-more (name one synopsis-item)))) ("synopsis-item" (element-content (seq one (name one main-text) (name optional annotation)))) ("tabular" (element-content (seq one (name one row-widths) (name zero-or-more row) (name optional annotation)))) ("text" (element-content (seq one (name one main-text) (name optional annotation)))) ("theme-text" (mixed-content pcdata)) ("title" (element-content (seq one (name one main-text) (name optional annotation)))))))

; Register the action procedure map of the language.
(register-xml-in-laml-action-procedures (quote leno1) (vector (list "begin-notes" (lambda (ast) (begin-notes! ast))) (list "end-notes" (lambda (ast) (end-notes! ast))) (list "leno-front-matters" (lambda (ast) (leno-front-matters! ast))) (list "note-page" (lambda (ast) (note-page! ast)))))

